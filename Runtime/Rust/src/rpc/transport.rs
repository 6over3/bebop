use crate::rpc::error::TransportResult;
use crate::{OwnedRecord, Record};
use async_trait::async_trait;
use std::future::Future;
use std::pin::Pin;

pub type TransportHandler<Datagram> =
    Pin<Box<dyn Fn(Datagram) -> Pin<Box<dyn Future<Output = ()>>>>>;

/// Transport protocol has a few main responsibilities:
/// 1. interpreting the raw stream as datagrams
/// 2. automatically reconnecting and dealing with network issues
/// 3. deciding how it wants to handle recv futures
///
/// The transport should not care what the data being sent is nor whether it is valid in the context
/// of the RPC service definitions. It only cares that the packets conform to the datagram
/// specification.
///
/// The `Datagram` type is autogenerated by the bebop compiler when you have at least one service
/// defined. There is no need to make a custom datagram structure.
#[async_trait]
pub trait TransportProtocol<Datagram: OwnedRecord> {
    /// This should only be called by the Router.
    fn _set_handler_boxed(&mut self, recv: TransportHandler<Datagram>);

    async fn send(&self, datagram: &Datagram) -> TransportResult<()>;
}
