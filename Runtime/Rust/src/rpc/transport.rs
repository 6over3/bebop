use crate::rpc::error::TransportResult;
use crate::rpc::Datagram;
use async_trait::async_trait;
use std::future::Future;
use std::pin::Pin;

pub type TransportHandler =
    Pin<Box<dyn Fn(&Datagram) -> Option<Pin<Box<dyn Future<Output = ()>>>>>>;

/// Transport protocol has a few main responsibilities:
/// 1. interpreting the raw stream as datagrams
/// 2. automatically reconnecting and dealing with network issues
/// 3. deciding how it wants to handle recv futures
///
/// The transport should not care what the data being sent is nor whether it is valid in the context
/// of the RPC service definitions. It only cares that the packets conform to the datagram
/// specification.
///
/// The `Datagram` type is autogenerated by the bebop compiler when you have at least one service
/// defined. There is no need to make a custom datagram structure.
#[async_trait]
pub trait TransportProtocol {
    /// This should only be called once by the Router during initial setup.
    ///
    /// This will await handling calls against our API which can be used to create backpressure or
    /// be ignored. Make sure that you are careful about awaiting these promises or spawning them
    /// on the runtime. Ideally if too many requests are being handled the transport can send
    /// some sort of error response to reject additional work.
    fn set_handler(&self, recv: TransportHandler);

    async fn send(&self, datagram: &Datagram) -> TransportResult;
}
