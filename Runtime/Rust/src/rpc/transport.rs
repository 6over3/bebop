use crate::rpc::errors::TransportResult;
use crate::Record;
use async_trait::async_trait;
use std::future::Future;
use std::pin::Pin;

pub type TransportHandler<Datagram> =
    Pin<Box<dyn Fn(Datagram) -> Pin<Box<dyn Future<Output = ()>>>>>;

/// Transport protocol has a few main responsibilities:
/// 1. interpreting the raw stream as datagrams
/// 2. automatically reconnecting and dealing with network issues
/// 3. deciding how it wants to handle recv futures
///
/// The transport should not care what the data being sent is nor whether it is valid in the context
/// of the RPC service definitions. It only cares that the packets conform to the datagram
/// specification.
///
/// The `Datagram` type is autogenerated by the bebop compiler when you have at least one service
/// defined. There is no need to make a custom datagram structure.
#[async_trait]
pub trait TransportProtocol<Datagram>
where
    for<'dgram> Datagram: Record<'dgram>,
{
    fn set_handler<F: 'static + Fn(Datagram) -> FReturn, FReturn: 'static + Future<Output = ()>>(
        &mut self,
        recv: F,
    ) {
        self.set_handler_boxed(Box::pin(move |v| Box::pin(recv(v))))
    }

    fn set_handler_boxed(&mut self, recv: TransportHandler<Datagram>);

    async fn send(&self, datagram: &Datagram) -> TransportResult;
}
