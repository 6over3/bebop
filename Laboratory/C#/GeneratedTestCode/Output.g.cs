//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:0.0.1-20210301-0356
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using global::System.Collections.Immutable;
using global::System.Linq;
using global::System;
using global::Bebop.Attributes;
using global::Bebop.Runtime;
using global::Bebop.Exceptions;
//
// This source code was auto-generated by bebopc, Version=0.0.1-20210301-0356.
//
namespace Bebop.Codegen {
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210301-0356")]
  [BebopRecord(BebopKind.Enum)]
  public enum Instrument : uint {
    Sax = 0,
    Trumpet = 1,
    Clarinet = 2
  }

  /// <summary>
  /// test
  /// </summary>
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210301-0356")]
  [BebopRecord(BebopKind.Struct, true)]
  public abstract record BaseMusician {
    public const uint OpCode = 0x5A5A414A;
    /// <summary>
    /// a name
    /// </summary>
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Name { get; init; }
    /// <summary>
    /// an instrument
    /// </summary>
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public Instrument Plays { get; init; }

    /// <summary>
    /// test
    /// </summary>
    protected BaseMusician() { }
    /// <summary>
    /// test
    /// </summary>
    /// <param name="name">a name</param>
    /// <param name="plays">an instrument</param>
    protected BaseMusician([System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull] string name, [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull] Instrument plays) => (Name, Plays) = (name, plays);
    public void Deconstruct([System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull] out string name, [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull] out Instrument plays) => (name, plays) = (Name, Plays);
  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210301-0356")]
  [BebopRecord(BebopKind.Struct, true)]
  public sealed record Musician : BaseMusician {

    /// <inheritdoc />
    public Musician() : base() { }
    /// <inheritdoc />
    public Musician([System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull] string name, [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull] Instrument plays) : base(name, plays) { }
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseMusician record) {
      var writer = BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseMusician record) {
      var writer = BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void __EncodeInto(BaseMusician record, ref BebopWriter writer) {
      writer.WriteString(record.Name);
      writer.WriteEnum<Instrument>(record.Plays);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Musician __DecodeFrom(ref BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      Instrument field1;
      field1 = reader.ReadEnum<Instrument>();
      return new Musician {
        Name = field0,
        Plays = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T __DecodeFrom<T>(ref BebopReader reader) where T: BaseMusician, new() {
      string field0;
      field0 = reader.ReadString();
      Instrument field1;
      field1 = reader.ReadEnum<Instrument>();
      return new T {
        Name = field0,
        Plays = field1,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210301-0356")]
  [BebopRecord(BebopKind.Message)]
  public abstract class BaseSong : System.IEquatable<BaseSong> {
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public string? Title { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public ushort? Year { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseMusician[]? Performers { get; set; }

    /// <summary>
    /// </summary>
    protected BaseSong() { }
    /// <summary>
    /// </summary>
    /// <param name="title"></param>
    /// <param name="year"></param>
    /// <param name="performers"></param>
    protected BaseSong([System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull] string? title, [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull] ushort? year, [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull] BaseMusician[]? performers) {
      Title = title;
      Year = year;
      Performers = performers;
    }
    #nullable disable
    public bool Equals(BaseSong other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Title == other.Title && Year == other.Year && (Performers is null ? other.Performers is null : other.Performers is not null && Performers.SequenceEqual(other.Performers));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseSong baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Title is not null) hash ^= Title.GetHashCode();
      if (Year is not null) hash ^= Year.Value.GetHashCode();
      if (Performers is not null) hash ^= Performers.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseSong left, BaseSong right) => Equals(left, right);
    public static bool operator !=(BaseSong left, BaseSong  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210301-0356")]
  [BebopRecord(BebopKind.Message)]
  public sealed class Song : BaseSong {

    /// <inheritdoc />
    #nullable enable
    public Song() : base() { }
    /// <inheritdoc />
    public Song([System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull] string? title, [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull] ushort? year, [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull] BaseMusician[]? performers) : base(title, year, performers) { }
    #nullable disable
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseSong record) {
      var writer = BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseSong record) {
      var writer = BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void __EncodeInto(BaseSong record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Title is not null) {
        writer.WriteByte(1);
        writer.WriteString(record.Title);
      }

      if (record.Year is not null) {
        writer.WriteByte(2);
        writer.WriteUInt16(record.Year.Value);
      }

      if (record.Performers is not null) {
        writer.WriteByte(3);
        {
          var length0 = unchecked((uint)record.Performers.Length);
          writer.WriteUInt32(length0);
          for (var i0 = 0; i0 < length0; i0++) {
            Bebop.Codegen.Musician.__EncodeInto(record.Performers[i0], ref writer);
          }
        }
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Song __DecodeFrom(ref BebopReader reader) {

      var record = new Song();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Title = reader.ReadString();
            break;
          case 2:
            record.Year = reader.ReadUInt16();
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.Performers = new BaseMusician[length0];
              for (var i0 = 0; i0 < length0; i0++) {
                BaseMusician x0;
                x0 = Bebop.Codegen.Musician.__DecodeFrom(ref reader);
                record.Performers[i0] = x0;
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T __DecodeFrom<T>(ref BebopReader reader) where T: BaseSong, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Title = reader.ReadString();
            break;
          case 2:
            record.Year = reader.ReadUInt16();
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.Performers = new BaseMusician[length0];
              for (var i0 = 0; i0 < length0; i0++) {
                BaseMusician x0;
                x0 = Bebop.Codegen.Musician.__DecodeFrom(ref reader);
                record.Performers[i0] = x0;
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210301-0356")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseLibrary : System.IEquatable<BaseLibrary> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BaseSong> Songs { get; set; }

    /// <summary>
    /// </summary>
    protected BaseLibrary() { }
    /// <summary>
    /// </summary>
    /// <param name="songs"></param>
    protected BaseLibrary([System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull] System.Collections.Generic.Dictionary<System.Guid, BaseSong> songs) {
      Songs = songs;
    }
    public bool Equals(BaseLibrary other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (Songs is null ? other.Songs is null : other.Songs is not null && Songs.SequenceEqual(other.Songs));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseLibrary baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Songs.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseLibrary left, BaseLibrary right) => Equals(left, right);
    public static bool operator !=(BaseLibrary left, BaseLibrary  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210301-0356")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class Library : BaseLibrary {

    /// <inheritdoc />
    public Library() : base() { }
    /// <inheritdoc />
    public Library([System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull] System.Collections.Generic.Dictionary<System.Guid, BaseSong> songs) : base(songs) { }
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseLibrary record) {
      var writer = BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseLibrary record) {
      var writer = BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void __EncodeInto(BaseLibrary record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.Songs.Count));
      foreach (var kv0 in record.Songs) {
        writer.WriteGuid(kv0.Key);
        Bebop.Codegen.Song.__EncodeInto(kv0.Value, ref writer);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return __DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Library __DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<System.Guid, BaseSong> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<System.Guid, BaseSong>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BaseSong v0;
          k0 = reader.ReadGuid();
          v0 = Bebop.Codegen.Song.__DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new Library {
        Songs = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T __DecodeFrom<T>(ref BebopReader reader) where T: BaseLibrary, new() {
      System.Collections.Generic.Dictionary<System.Guid, BaseSong> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<System.Guid, BaseSong>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BaseSong v0;
          k0 = reader.ReadGuid();
          v0 = Bebop.Codegen.Song.__DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new T {
        Songs = field0,
      };
    }

  }

}
