//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           0.0.1-20211003-2047
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//
// This source code was auto-generated by bebopc, Version=0.0.1-20211003-2047.
//
namespace Bebop.Codegen {

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20211003-2047")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Enum)]
  public enum Instrument : uint {
    Sax = 0,
    Trumpet = 1,
    Clarinet = 2
  }

  /// <summary>
  /// <para>test</para>
  /// </summary>
  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20211003-2047")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct, true)]
  public partial class Musician : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Musician> {
    public const uint OpCode = 0x5A5A414A;
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    /// <summary>
    /// <para>a name</para>
    /// </summary>
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Name { get; init; }
    /// <summary>
    /// <para>an instrument</para>
    /// </summary>
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public global::Bebop.Codegen.Instrument Plays { get; init; }

    /// <summary>
    /// <para>test</para>
    /// </summary>
    public Musician() : base() { }
    /// <summary>
    /// <para>test</para>
    /// </summary>
    /// <param name="name">
    /// <para>a name</para>
    /// </param>
    /// <param name="plays">
    /// <para>an instrument</para>
    /// </param>
    public Musician([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] string name, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] global::Bebop.Codegen.Instrument plays) => (Name, Plays) = (name, plays);
    public Musician([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Musician original) => (Name, Plays) = (original.Name, original.Plays);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out string name, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out global::Bebop.Codegen.Instrument plays) => (name, plays) = (Name, Plays);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(Name.Length);
      byteCount += sizeof(uint);
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(Name);
      byteCount += sizeof(uint);
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Musician record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Musician record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Musician record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Musician record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override int EncodeIntoBuffer(byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(this, ref writer);
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static int EncodeIntoBuffer(global::Bebop.Codegen.Musician record, byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(record, ref writer);
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Musician Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Musician record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      writer.WriteString(record.Name);
      writer.WriteEnum<global::Bebop.Codegen.Instrument>(record.Plays);
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Musician __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      global::Bebop.Codegen.Instrument field1;
      field1 = reader.ReadEnum<global::Bebop.Codegen.Instrument>();
      return new global::Bebop.Codegen.Musician {
        Name = field0,
        Plays = field1,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Musician other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Name == other.Name && Plays == other.Plays;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Musician baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Name.GetHashCode();
      hash ^= Plays.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Musician left, global::Bebop.Codegen.Musician right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Musician left, global::Bebop.Codegen.Musician  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20211003-2047")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Message)]
  public partial class Song : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Song> {
    #nullable enable
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public string? Title { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public ushort? Year { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public global::Bebop.Codegen.Musician[]? Performers { get; set; }

    /// <summary>
    /// </summary>
    public Song() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="title">
    /// </param>
    /// <param name="year">
    /// </param>
    /// <param name="performers">
    /// </param>
    public Song([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] string? title, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] ushort? year, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] global::Bebop.Codegen.Musician[]? performers) => (Title, Year, Performers) = (title, year, performers);
    public Song([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] Song? original) => (Title, Year, Performers) = (original?.Title, original?.Year, original?.Performers);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out string? title, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out ushort? year, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out global::Bebop.Codegen.Musician[]? performers) => (title, year, performers) = (Title, Year, Performers);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (Title is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(Title.Length);
      }
      if (Year is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(ushort);
      }
      if (Performers is not null) {
        byteCount += sizeof(byte);
        {
          var length0 = unchecked((uint)Performers.Length);
          byteCount += sizeof(uint);
          for (var i0 = 0; i0 < length0; i0++) {
            byteCount += Performers[i0].MaxByteCount;
          }
        }
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (Title is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(Title);
      }
      if (Year is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(ushort);
      }
      if (Performers is not null) {
        byteCount += sizeof(byte);
        {
          var length0 = unchecked((uint)Performers.Length);
          byteCount += sizeof(uint);
          for (var i0 = 0; i0 < length0; i0++) {
            byteCount += Performers[i0].ByteCount;
          }
        }
      }
      return byteCount;
    }

    #nullable disable

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Song record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Song record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Song record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Song record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override int EncodeIntoBuffer(byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(this, ref writer);
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static int EncodeIntoBuffer(global::Bebop.Codegen.Song record, byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(record, ref writer);
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Song Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Song record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Title is not null) {
        writer.WriteByte(1);
        writer.WriteString(record.Title);
      }

      if (record.Year is not null) {
        writer.WriteByte(2);
        writer.WriteUInt16(record.Year.Value);
      }

      if (record.Performers is not null) {
        writer.WriteByte(3);
        {
          var length0 = unchecked((uint)record.Performers.Length);
          writer.WriteUInt32(length0);
          for (var i0 = 0; i0 < length0; i0++) {
            global::Bebop.Codegen.Musician.__EncodeInto(record.Performers[i0], ref writer);
          }
        }
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Song __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      var record = new global::Bebop.Codegen.Song();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Title = reader.ReadString();
            break;
          case 2:
            record.Year = reader.ReadUInt16();
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.Performers = new global::Bebop.Codegen.Musician[length0];
              for (var i0 = 0; i0 < length0; i0++) {
                global::Bebop.Codegen.Musician x0;
                x0 = global::Bebop.Codegen.Musician.__DecodeFrom(ref reader);
                record.Performers[i0] = x0;
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Song other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Title == other.Title && Year == other.Year && (Performers is null ? other.Performers is null : other.Performers is not null && global::System.Linq.Enumerable.SequenceEqual(Performers, other.Performers));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Song baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Title is not null) hash ^= Title.GetHashCode();
      if (Year is not null) hash ^= Year.Value.GetHashCode();
      if (Performers is not null) hash ^= Performers.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Song left, global::Bebop.Codegen.Song right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Song left, global::Bebop.Codegen.Song  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20211003-2047")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class Library : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<Library> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song> Songs { get; set; }

    /// <summary>
    /// </summary>
    public Library() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="songs">
    /// </param>
    public Library([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song> songs) => (Songs) = (songs);
    public Library([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Library original) => (Songs) = (original.Songs);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song> songs) => (songs) = (Songs);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint);
      foreach (var kv0 in Songs) {
        byteCount += 16;
        byteCount += kv0.Value.MaxByteCount;
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint);
      foreach (var kv0 in Songs) {
        byteCount += 16;
        byteCount += kv0.Value.ByteCount;
      }
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Library record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Library record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Library record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Library record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override int EncodeIntoBuffer(byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(this, ref writer);
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static int EncodeIntoBuffer(global::Bebop.Codegen.Library record, byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(record, ref writer);
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Library Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.Library record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      writer.WriteUInt32(unchecked((uint)record.Songs.Count));
      foreach (var kv0 in record.Songs) {
        writer.WriteGuid(kv0.Key);
        global::Bebop.Codegen.Song.__EncodeInto(kv0.Value, ref writer);
      }
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.Library __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new global::System.Collections.Generic.Dictionary<global::System.Guid, global::Bebop.Codegen.Song>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          global::System.Guid k0;
          global::Bebop.Codegen.Song v0;
          k0 = reader.ReadGuid();
          v0 = global::Bebop.Codegen.Song.__DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new global::Bebop.Codegen.Library {
        Songs = field0,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.Library other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (Songs is null ? other.Songs is null : other.Songs is not null && global::System.Linq.Enumerable.SequenceEqual(Songs, other.Songs));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.Library baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Songs.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.Library left, global::Bebop.Codegen.Library right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.Library left, global::Bebop.Codegen.Library  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20211003-2047")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class StudioAlbum : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<StudioAlbum> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public global::Bebop.Codegen.Song[] Tracks { get; set; }

    /// <summary>
    /// </summary>
    public StudioAlbum() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="tracks">
    /// </param>
    public StudioAlbum([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] global::Bebop.Codegen.Song[] tracks) => (Tracks) = (tracks);
    public StudioAlbum([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] StudioAlbum original) => (Tracks) = (original.Tracks);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out global::Bebop.Codegen.Song[] tracks) => (tracks) = (Tracks);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      {
        var length0 = unchecked((uint)Tracks.Length);
        byteCount += sizeof(uint);
        for (var i0 = 0; i0 < length0; i0++) {
          byteCount += Tracks[i0].MaxByteCount;
        }
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      {
        var length0 = unchecked((uint)Tracks.Length);
        byteCount += sizeof(uint);
        for (var i0 = 0; i0 < length0; i0++) {
          byteCount += Tracks[i0].ByteCount;
        }
      }
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.StudioAlbum record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.StudioAlbum record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.StudioAlbum record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.StudioAlbum record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override int EncodeIntoBuffer(byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(this, ref writer);
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static int EncodeIntoBuffer(global::Bebop.Codegen.StudioAlbum record, byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(record, ref writer);
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.StudioAlbum Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.StudioAlbum Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.StudioAlbum Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.StudioAlbum Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.StudioAlbum Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.StudioAlbum record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      {
        var length0 = unchecked((uint)record.Tracks.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          global::Bebop.Codegen.Song.__EncodeInto(record.Tracks[i0], ref writer);
        }
      }
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.StudioAlbum __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      global::Bebop.Codegen.Song[] field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new global::Bebop.Codegen.Song[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          global::Bebop.Codegen.Song x0;
          x0 = global::Bebop.Codegen.Song.__DecodeFrom(ref reader);
          field0[i0] = x0;
        }
      }
      return new global::Bebop.Codegen.StudioAlbum {
        Tracks = field0,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.StudioAlbum other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (Tracks is null ? other.Tracks is null : other.Tracks is not null && global::System.Linq.Enumerable.SequenceEqual(Tracks, other.Tracks));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.StudioAlbum baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Tracks.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.StudioAlbum left, global::Bebop.Codegen.StudioAlbum right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.StudioAlbum left, global::Bebop.Codegen.StudioAlbum  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20211003-2047")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Message)]
  public partial class LiveAlbum : global::Bebop.Runtime.BaseBebopRecord, global::System.IEquatable<LiveAlbum> {
    #nullable enable
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public global::Bebop.Codegen.Song[]? Tracks { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public string? VenueName { get; set; }
    [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull]
    public global::System.DateTime? ConcertDate { get; set; }

    /// <summary>
    /// </summary>
    public LiveAlbum() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="tracks">
    /// </param>
    /// <param name="venueName">
    /// </param>
    /// <param name="concertDate">
    /// </param>
    public LiveAlbum([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] global::Bebop.Codegen.Song[]? tracks, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] string? venueName, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] global::System.DateTime? concertDate) => (Tracks, VenueName, ConcertDate) = (tracks, venueName, concertDate);
    public LiveAlbum([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] LiveAlbum? original) => (Tracks, VenueName, ConcertDate) = (original?.Tracks, original?.VenueName, original?.ConcertDate);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out global::Bebop.Codegen.Song[]? tracks, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out string? venueName, [global::System.Diagnostics.CodeAnalysis.MaybeNull, global::System.Diagnostics.CodeAnalysis.AllowNull] out global::System.DateTime? concertDate) => (tracks, venueName, concertDate) = (Tracks, VenueName, ConcertDate);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (Tracks is not null) {
        byteCount += sizeof(byte);
        {
          var length0 = unchecked((uint)Tracks.Length);
          byteCount += sizeof(uint);
          for (var i0 = 0; i0 < length0; i0++) {
            byteCount += Tracks[i0].MaxByteCount;
          }
        }
      }
      if (VenueName is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(VenueName.Length);
      }
      if (ConcertDate is not null) {
        byteCount += sizeof(byte);
        byteCount += 8;
      }
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += 5;
      if (Tracks is not null) {
        byteCount += sizeof(byte);
        {
          var length0 = unchecked((uint)Tracks.Length);
          byteCount += sizeof(uint);
          for (var i0 = 0; i0 < length0; i0++) {
            byteCount += Tracks[i0].ByteCount;
          }
        }
      }
      if (VenueName is not null) {
        byteCount += sizeof(byte);
        byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(VenueName);
      }
      if (ConcertDate is not null) {
        byteCount += sizeof(byte);
        byteCount += 8;
      }
      return byteCount;
    }

    #nullable disable

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.LiveAlbum record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.LiveAlbum record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.LiveAlbum record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.LiveAlbum record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override int EncodeIntoBuffer(byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(this, ref writer);
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static int EncodeIntoBuffer(global::Bebop.Codegen.LiveAlbum record, byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(record, ref writer);
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.LiveAlbum Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.LiveAlbum Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.LiveAlbum Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.LiveAlbum Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.LiveAlbum Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Bebop.Codegen.LiveAlbum record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Tracks is not null) {
        writer.WriteByte(1);
        {
          var length0 = unchecked((uint)record.Tracks.Length);
          writer.WriteUInt32(length0);
          for (var i0 = 0; i0 < length0; i0++) {
            global::Bebop.Codegen.Song.__EncodeInto(record.Tracks[i0], ref writer);
          }
        }
      }

      if (record.VenueName is not null) {
        writer.WriteByte(2);
        writer.WriteString(record.VenueName);
      }

      if (record.ConcertDate is not null) {
        writer.WriteByte(3);
        writer.WriteDate(record.ConcertDate.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Bebop.Codegen.LiveAlbum __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      var record = new global::Bebop.Codegen.LiveAlbum();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.Tracks = new global::Bebop.Codegen.Song[length0];
              for (var i0 = 0; i0 < length0; i0++) {
                global::Bebop.Codegen.Song x0;
                x0 = global::Bebop.Codegen.Song.__DecodeFrom(ref reader);
                record.Tracks[i0] = x0;
              }
            }
            break;
          case 2:
            record.VenueName = reader.ReadString();
            break;
          case 3:
            record.ConcertDate = reader.ReadDate();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    #endregion
    #region Equality
    public bool Equals(global::Bebop.Codegen.LiveAlbum other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (Tracks is null ? other.Tracks is null : other.Tracks is not null && global::System.Linq.Enumerable.SequenceEqual(Tracks, other.Tracks)) && VenueName == other.VenueName && ConcertDate == other.ConcertDate;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Bebop.Codegen.LiveAlbum baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Tracks is not null) hash ^= Tracks.GetHashCode();
      if (VenueName is not null) hash ^= VenueName.GetHashCode();
      if (ConcertDate is not null) hash ^= ConcertDate.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Bebop.Codegen.LiveAlbum left, global::Bebop.Codegen.LiveAlbum right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.LiveAlbum left, global::Bebop.Codegen.LiveAlbum  right) => !Equals(left, right);
    #endregion

  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20211003-2047")]
  public abstract class BaseAlbum<T0, T1> : global::Bebop.Runtime.BaseBebopRecord where T0: global::Bebop.Codegen.StudioAlbum where T1: global::Bebop.Codegen.LiveAlbum {
    internal readonly T0 _value0;
    internal readonly T1 _value1;
    private readonly byte _discriminator;

    protected private BaseAlbum() { }
    protected BaseAlbum(global::Bebop.Codegen.AlbumUnion<T0, T1> input) {
        _discriminator = input.Discriminator;
        switch (_discriminator) {
          case 1: _value0 = input.AsStudioAlbum; break;
          case 2: _value1 = input.AsLiveAlbum; break;
          default: throw new global::Bebop.Exceptions.BebopRuntimeException();
        }
    }

    public global::Bebop.Runtime.BaseBebopRecord Value => _discriminator switch {
        1 => _value0,
        2 => _value1,
        _ => throw new global::Bebop.Exceptions.BebopRuntimeException()
    };

    public byte Discriminator => _discriminator;

    #region IsAs
    public bool IsStudioAlbum => _discriminator is 1;
    public T0 AsStudioAlbum => _discriminator is 1 ? _value0 : throw new global::System.NotImplementedException($"Cannot return as StudioAlbum as result is T0");

    public bool IsLiveAlbum => _discriminator is 2;
    public T1 AsLiveAlbum => _discriminator is 2 ? _value1 : throw new global::System.NotImplementedException($"Cannot return as LiveAlbum as result is T1");

    #endregion
    public void Switch(global::System.Action<T0> f0, global::System.Action<T1> f1) {
        if (_discriminator is 1 && f0 is not null) {
          f0(_value0);
          return;
        }
        if (_discriminator is 2 && f1 is not null) {
          f1(_value1);
          return;
        }
        throw new global::Bebop.Exceptions.BebopRuntimeException();
    }

    public TResult Match<TResult>(global::System.Func<T0, TResult> f0, global::System.Func<T1, TResult> f1) => _discriminator switch {
        1 when f0 is not null => f0(_value0),
        2 when f1 is not null => f1(_value1),
        _ => throw new global::Bebop.Exceptions.BebopRuntimeException()
    };

    #region Equality
    private bool Equals(global::Bebop.Codegen.BaseAlbum<T0, T1> other) => _discriminator == other.Discriminator && _discriminator switch {
        1 => Equals(_value0, other._value0),
        2 => Equals(_value1, other._value1),
        _ => false
    };

    public override bool Equals(object other) {
        if (ReferenceEquals(null, other)) {
          return false;
        }
        if (ReferenceEquals(this, other)) {
          return true;
        }
        return other is global::Bebop.Codegen.BaseAlbum<T0, T1> o && Equals(o);
    }

    public static bool operator ==(global::Bebop.Codegen.BaseAlbum<T0, T1> left, global::Bebop.Codegen.BaseAlbum<T0, T1> right) => Equals(left, right);
    public static bool operator !=(global::Bebop.Codegen.BaseAlbum<T0, T1> left, global::Bebop.Codegen.BaseAlbum<T0, T1> right) => !Equals(left, right);
    public override int GetHashCode() => (_discriminator switch {
        1 => _value0?.GetHashCode() ?? 0,
        2 => _value1?.GetHashCode() ?? 0,
        _ => 0
    } * 397) ^ _discriminator;

    #endregion
  }

  /// <inheritdoc />
  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20211003-2047")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Union)]
  public partial class Album : global::Bebop.Codegen.BaseAlbum<global::Bebop.Codegen.StudioAlbum, global::Bebop.Codegen.LiveAlbum> {

    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();

    protected private Album(): base() { }
    private Album(global::Bebop.Codegen.AlbumUnion<global::Bebop.Codegen.StudioAlbum, global::Bebop.Codegen.LiveAlbum> _) : base(_) { }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Album record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Bebop.Codegen.Album record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Album record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Bebop.Codegen.Album record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override int EncodeIntoBuffer(byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(this, ref writer);
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static int EncodeIntoBuffer(global::Bebop.Codegen.Album record, byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(record, ref writer);
    }

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + sizeof(byte) + Discriminator switch {
          1 => AsStudioAlbum.MaxByteCount,
          2 => AsLiveAlbum.MaxByteCount,
          _ => throw new global::Bebop.Exceptions.BebopRuntimeException()
      };
      return byteCount;
    }

    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint) + sizeof(byte) + Discriminator switch {
          1 => AsStudioAlbum.ByteCount,
          2 => AsLiveAlbum.ByteCount,
          _ => throw new global::Bebop.Exceptions.BebopRuntimeException()
      };
      return byteCount;
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Album Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Album Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Album Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Album Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Bebop.Codegen.Album Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Implicit Overrides
    public static implicit operator global::Bebop.Codegen.Album(global::Bebop.Codegen.StudioAlbum _) => new (_);
    public static global::Bebop.Codegen.Album FromStudioAlbum(global::Bebop.Codegen.StudioAlbum input) => new (input);

    public static implicit operator global::Bebop.Codegen.Album(global::Bebop.Codegen.LiveAlbum _) => new (_);
    public static global::Bebop.Codegen.Album FromLiveAlbum(global::Bebop.Codegen.LiveAlbum input) => new (input);

    #endregion
    #region Internal Use
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    internal static int __EncodeInto(global::Bebop.Codegen.Album record, ref global::Bebop.Runtime.BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      writer.WriteByte(record.Discriminator);
      var start = writer.Length;
      switch (record.Discriminator) {
        case 1: global::Bebop.Codegen.StudioAlbum.__EncodeInto(record.AsStudioAlbum, ref writer); break;
        case 2: global::Bebop.Codegen.LiveAlbum.__EncodeInto(record.AsLiveAlbum, ref writer); break;
      }
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
      var after = writer.Length;
      return after - start;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    internal static global::Bebop.Codegen.Album __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length + 1));
      switch (reader.ReadByte()) {
        case 1:
            return global::Bebop.Codegen.StudioAlbum.__DecodeFrom(ref reader);
        case 2:
            return global::Bebop.Codegen.LiveAlbum.__DecodeFrom(ref reader);
        default:
            reader.Position = end;
            return null;
        }
    }

    #endregion
  }

  /// <inheritdoc />
  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20211003-2047")]
  public readonly struct AlbumUnion<T0, T1> where T0: global::Bebop.Codegen.StudioAlbum where T1: global::Bebop.Codegen.LiveAlbum {

    internal readonly T0 _value0;
    internal readonly T1 _value1;
    private readonly byte _discriminator;

    private AlbumUnion(byte discriminator, T0 value0 = default, T1 value1 = default) {
        _discriminator = discriminator;
        _value0 = value0;
        _value1 = value1;
    }

    public global::Bebop.Runtime.BaseBebopRecord Value => _discriminator switch {
        1 => _value0,
        2 => _value1,
        _ => throw new global::Bebop.Exceptions.BebopRuntimeException()
    };

    public byte Discriminator => _discriminator;

    #region IsAs
    public bool IsStudioAlbum => _discriminator is 1;
    public T0 AsStudioAlbum => _discriminator is 1 ? _value0 : throw new global::System.NotImplementedException($"Cannot return as StudioAlbum as result is T0");

    public bool IsLiveAlbum => _discriminator is 2;
    public T1 AsLiveAlbum => _discriminator is 2 ? _value1 : throw new global::System.NotImplementedException($"Cannot return as LiveAlbum as result is T1");

    #endregion
    #region Implicit Overrides
    public static implicit operator global::Bebop.Codegen.AlbumUnion<T0, T1>(T0 t) => new  global::Bebop.Codegen.AlbumUnion<T0, T1>(1, value0: t);
    public static global::Bebop.Codegen.AlbumUnion<T0, T1> FromBaseStudioAlbum(T0 input) => input;

    public static implicit operator global::Bebop.Codegen.AlbumUnion<T0, T1>(T1 t) => new  global::Bebop.Codegen.AlbumUnion<T0, T1>(2, value1: t);
    public static global::Bebop.Codegen.AlbumUnion<T0, T1> FromBaseLiveAlbum(T1 input) => input;

    #endregion

    public void Switch(global::System.Action<T0> f0, global::System.Action<T1> f1) {
        if (_discriminator is 1 && f0 is not null) {
          f0(_value0);
          return;
        }
        if (_discriminator is 2 && f1 is not null) {
          f1(_value1);
          return;
        }
        throw new global::Bebop.Exceptions.BebopRuntimeException();
    }

    public TResult Match<TResult>(global::System.Func<T0, TResult> f0, global::System.Func<T1, TResult> f1) => _discriminator switch {
        1 when f0 is not null => f0(_value0),
        2 when f1 is not null => f1(_value1),
        _ => throw new global::Bebop.Exceptions.BebopRuntimeException()
    };

    #region Equality
    private bool Equals(global::Bebop.Codegen.BaseAlbum<T0, T1> other) => _discriminator == other.Discriminator && _discriminator switch {
        1 => Equals(_value0, other._value0),
        2 => Equals(_value1, other._value1),
        _ => false
    };

    public override bool Equals(object other) {
        if (ReferenceEquals(null, other)) {
          return false;
        }
        return other is global::Bebop.Codegen.BaseAlbum<T0, T1> o && Equals(o);
    }

    public override int GetHashCode() => (_discriminator switch {
        1 => _value0?.GetHashCode() ?? 0,
        2 => _value1?.GetHashCode() ?? 0,
        _ => 0
    } * 397) ^ _discriminator;

    #endregion
  }

}
