using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using Bebop.Exceptions;

namespace Bebop.Extensions
{
    /// <summary>
    ///     Handy dandy extension methods for working with <see cref="Type"/>
    /// </summary>
    internal static class TypeExtensions
    {
        /// <summary>
        ///     Attempts to find the generated static decode method of the specified Bebop <paramref name="type"/>
        /// </summary>
        /// <param name="type">A type that was created by the Bebop compiler.</param>
        /// <returns>The <see cref="MethodInfo"/> of "Decode"</returns>
        /// <exception cref="BebopRuntimeException">
        ///     Thrown when the decode method of the specified <paramref name="type"/> cannot be loaded.
        /// </exception>
        private static MethodInfo GetStaticDecode(this Type type)
        {
            var decodeMethod = type.GetMethod("Decode",
                BindingFlags.Static | BindingFlags.Public,
                null,
                new[] {typeof(byte[])},
                null);
            if (decodeMethod is null)
            {
                throw new BebopRuntimeException($"Unable to find static decode method in \"{type.FullName}\"");
            }
            return decodeMethod;
        }

        /// <summary>
        ///     Converts a <see cref="Type"/> into a <see cref="BebopType{T}"/>
        /// </summary>
        /// <param name="type">A type that was marked with <see cref="BebopMarkerAttribute"/></param>
        /// <returns>
        ///     An instance of <see cref="BebopType"/> that can be used to virtually access <see cref="BebopType{T}"/>
        /// </returns>
        /// <exception cref="BebopRuntimeException"/>
        internal static BebopType ToBebopType(this Type type)
        {
            const string opcodeFieldName = "OpCode";

            if (type.BaseType is null)
            {
                throw new BebopRuntimeException($"Provided type \"{type.FullName}\" does not contain a base class.");
            }

            var decodeMethod = type.GetStaticDecode();
            var encodeMethod = type.GetStaticEncode();

            var constructor = typeof(BebopType<>).MakeGenericType(type)
                .GetConstructors(BindingFlags.NonPublic | BindingFlags.Instance)
                .FirstOrDefault();

            if (constructor is null)
            {
                throw new BebopRuntimeException(
                    $"Cannot locate constructor for BebopType<T> using \"{type.FullName}\"");
            }

            var opcode = type.BaseType.GetField(opcodeFieldName)?.GetRawConstantValue() is uint v
                ? (int) v
                : -1;

            return (BebopType) constructor.Invoke(new object[] {type, encodeMethod, decodeMethod, opcode});
        }

        /// <summary>
        ///     Attempts to find the generated static encode method of the specified Bebop <paramref name="type"/>
        /// </summary>
        /// <param name="type">A type that was created by the Bebop compiler.</param>
        /// <returns>The <see cref="MethodInfo"/> of "Encode"</returns>
        /// <exception cref="BebopRuntimeException">
        ///     Thrown when the encode method of the specified <paramref name="type"/> cannot be loaded.
        /// </exception>
        private static MethodInfo GetStaticEncode(this Type type)
        {
            Debug.Assert(type.BaseType != null, "type.BaseType != null");
            var encodeMethod = type.GetMethod("Encode",
                BindingFlags.Static | BindingFlags.Public,
                null,
                new[] {type.BaseType},
                null);

            if (encodeMethod is null)
            {
                throw new BebopRuntimeException($"Unable to find static encode method in \"{type.FullName}\"");
            }
            return encodeMethod;
        }

        /// <summary>
        ///     Walks an assembly and finds types with the <see cref="BebopMarkerAttribute"/>
        /// </summary>
        /// <param name="assembly">The assembly that will be scanned.</param>
        /// <returns>A collection of types that were generated by Bebop</returns>
        /// <remarks>
        ///     In the event an exception occurs due to a type being inaccessible, this method leverages the types made available
        ///     in <see cref="ReflectionTypeLoadException"/>
        /// </remarks>
        internal static IEnumerable<Type?> GetMarkedTypes(this Assembly assembly)
        {
            if (assembly is null)
            {
                throw new ArgumentNullException(nameof(assembly));
            }
            try
            {
                return assembly.DefinedTypes.Where(t
                        => t.GetCustomAttribute<BebopMarkerAttribute>() is not null)
                    .Select(t => t.AsType());
            }
            catch (ReflectionTypeLoadException e)
            {
                return e.Types.Where(t => t?.GetCustomAttribute<BebopMarkerAttribute>() is not null);
            }
        }
    }
}