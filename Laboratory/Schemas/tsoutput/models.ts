//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           0.0.1-20210810-2118
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError } from "bebop";

export interface IArrayOfStrings {
  strings: Array<string>;
}

export const ArrayOfStrings = {
  encode(message: IArrayOfStrings): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IArrayOfStrings, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.strings.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeString(message.strings[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IArrayOfStrings {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IArrayOfStrings {
    let field0: Array<string>;
    {
      let length0 = view.readUint32();
      field0 = new Array<string>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: string;
        x0 = view.readString();
        field0[i0] = x0;
      }
    }
    let message: IArrayOfStrings = {
      strings: field0,
    };
    return message;
  },
};

export interface IBasicArrays {
  a_bool: Array<boolean>;
  a_byte: Uint8Array;
  a_int16: Array<number>;
  a_uint16: Array<number>;
  a_int32: Array<number>;
  a_uint32: Array<number>;
  a_int64: Array<bigint>;
  a_uint64: Array<bigint>;
  a_float32: Array<number>;
  a_float64: Array<number>;
  a_string: Array<string>;
  a_guid: Array<string>;
}

export const BasicArrays = {
  encode(message: IBasicArrays): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBasicArrays, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.a_bool.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeByte(Number(message.a_bool[i0]));
        }
      }
      view.writeBytes(message.a_byte);
      {
        const length0 = message.a_int16.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeInt16(message.a_int16[i0]);
        }
      }
      {
        const length0 = message.a_uint16.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeUint16(message.a_uint16[i0]);
        }
      }
      {
        const length0 = message.a_int32.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeInt32(message.a_int32[i0]);
        }
      }
      {
        const length0 = message.a_uint32.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeUint32(message.a_uint32[i0]);
        }
      }
      {
        const length0 = message.a_int64.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeInt64(message.a_int64[i0]);
        }
      }
      {
        const length0 = message.a_uint64.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeUint64(message.a_uint64[i0]);
        }
      }
      {
        const length0 = message.a_float32.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeFloat32(message.a_float32[i0]);
        }
      }
      {
        const length0 = message.a_float64.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeFloat64(message.a_float64[i0]);
        }
      }
      {
        const length0 = message.a_string.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeString(message.a_string[i0]);
        }
      }
      {
        const length0 = message.a_guid.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeGuid(message.a_guid[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBasicArrays {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBasicArrays {
    let field0: Array<boolean>;
    {
      let length0 = view.readUint32();
      field0 = new Array<boolean>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: boolean;
        x0 = !!view.readByte();
        field0[i0] = x0;
      }
    }
    let field1: Uint8Array;
    field1 = view.readBytes();
    let field2: Array<number>;
    {
      let length0 = view.readUint32();
      field2 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readInt16();
        field2[i0] = x0;
      }
    }
    let field3: Array<number>;
    {
      let length0 = view.readUint32();
      field3 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readUint16();
        field3[i0] = x0;
      }
    }
    let field4: Array<number>;
    {
      let length0 = view.readUint32();
      field4 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readInt32();
        field4[i0] = x0;
      }
    }
    let field5: Array<number>;
    {
      let length0 = view.readUint32();
      field5 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readUint32();
        field5[i0] = x0;
      }
    }
    let field6: Array<bigint>;
    {
      let length0 = view.readUint32();
      field6 = new Array<bigint>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: bigint;
        x0 = view.readInt64();
        field6[i0] = x0;
      }
    }
    let field7: Array<bigint>;
    {
      let length0 = view.readUint32();
      field7 = new Array<bigint>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: bigint;
        x0 = view.readUint64();
        field7[i0] = x0;
      }
    }
    let field8: Array<number>;
    {
      let length0 = view.readUint32();
      field8 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readFloat32();
        field8[i0] = x0;
      }
    }
    let field9: Array<number>;
    {
      let length0 = view.readUint32();
      field9 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readFloat64();
        field9[i0] = x0;
      }
    }
    let field10: Array<string>;
    {
      let length0 = view.readUint32();
      field10 = new Array<string>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: string;
        x0 = view.readString();
        field10[i0] = x0;
      }
    }
    let field11: Array<string>;
    {
      let length0 = view.readUint32();
      field11 = new Array<string>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: string;
        x0 = view.readGuid();
        field11[i0] = x0;
      }
    }
    let message: IBasicArrays = {
      a_bool: field0,
      a_byte: field1,
      a_int16: field2,
      a_uint16: field3,
      a_int32: field4,
      a_uint32: field5,
      a_int64: field6,
      a_uint64: field7,
      a_float32: field8,
      a_float64: field9,
      a_string: field10,
      a_guid: field11,
    };
    return message;
  },
};

export interface ITestInt32Array {
  a: Array<number>;
}

export const TestInt32Array = {
  encode(message: ITestInt32Array): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ITestInt32Array, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.a.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeInt32(message.a[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ITestInt32Array {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ITestInt32Array {
    let field0: Array<number>;
    {
      let length0 = view.readUint32();
      field0 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readInt32();
        field0[i0] = x0;
      }
    }
    let message: ITestInt32Array = {
      a: field0,
    };
    return message;
  },
};

export interface IBasicTypes {
  a_bool: boolean;
  a_byte: number;
  a_int16: number;
  a_uint16: number;
  a_int32: number;
  a_uint32: number;
  a_int64: bigint;
  a_uint64: bigint;
  a_float32: number;
  a_float64: number;
  a_string: string;
  a_guid: string;
  a_date: Date;
}

export const BasicTypes = {
  encode(message: IBasicTypes): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBasicTypes, view: BebopView): number {
    const before = view.length;
      view.writeByte(Number(message.a_bool));
      view.writeByte(message.a_byte);
      view.writeInt16(message.a_int16);
      view.writeUint16(message.a_uint16);
      view.writeInt32(message.a_int32);
      view.writeUint32(message.a_uint32);
      view.writeInt64(message.a_int64);
      view.writeUint64(message.a_uint64);
      view.writeFloat32(message.a_float32);
      view.writeFloat64(message.a_float64);
      view.writeString(message.a_string);
      view.writeGuid(message.a_guid);
      view.writeDate(message.a_date);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBasicTypes {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBasicTypes {
    let field0: boolean;
    field0 = !!view.readByte();
    let field1: number;
    field1 = view.readByte();
    let field2: number;
    field2 = view.readInt16();
    let field3: number;
    field3 = view.readUint16();
    let field4: number;
    field4 = view.readInt32();
    let field5: number;
    field5 = view.readUint32();
    let field6: bigint;
    field6 = view.readInt64();
    let field7: bigint;
    field7 = view.readUint64();
    let field8: number;
    field8 = view.readFloat32();
    let field9: number;
    field9 = view.readFloat64();
    let field10: string;
    field10 = view.readString();
    let field11: string;
    field11 = view.readGuid();
    let field12: Date;
    field12 = view.readDate();
    let message: IBasicTypes = {
      a_bool: field0,
      a_byte: field1,
      a_int16: field2,
      a_uint16: field3,
      a_int32: field4,
      a_uint32: field5,
      a_int64: field6,
      a_uint64: field7,
      a_float32: field8,
      a_float64: field9,
      a_string: field10,
      a_guid: field11,
      a_date: field12,
    };
    return message;
  },
};

export const exampleConstInt32: number = -123;

export const exampleConstUint64: bigint = BigInt("0x123ffffffff");

export const exampleConstFloat64: number = 123.45678e9;

export const exampleConstInf: number = Number.POSITIVE_INFINITY;

export const exampleConstNegInf: number = Number.NEGATIVE_INFINITY;

export const exampleConstNan: number = Number.NaN;

export const exampleConstFalse: boolean = false;

export const exampleConstTrue: boolean = true;

export const exampleConstString: string = "hello \"world\"\r\nwith newlines";

export const exampleConstGuid: string = "e215a946-b26f-4567-a276-13136f0a1708";

export enum DepE {
  /**
   * @deprecated X in DepE
   */
  X = 1,
}

export interface IDepM {
  /**
   * @deprecated x in DepM
   */
  x?: number;
}

export const DepM = {
  encode(message: IDepM): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IDepM, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IDepM {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IDepM {
    let message: IDepM = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.x = view.readInt32();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

/**
 * Documented enum
 */
export enum DocE {
  /**
   * Documented constant
   */
  X = 1,
  /**
   * @deprecated Y in DocE
   */
  Y = 2,
  /**
   * Deprecated, documented constant
   * @deprecated Z in DocE
   */
  Z = 3,
}

/**
 * Documented message
 */
export interface IDocM {
  /**
   * Documented field
   */
  x?: number;
  /**
   * @deprecated y in DocM
   */
  y?: number;
  /**
   * Deprecated, documented field
   * @deprecated z in DocM
   */
  z?: number;
}

export const DocM = {
  encode(message: IDocM): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IDocM, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.x != null) {
        view.writeByte(1);
        view.writeInt32(message.x);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IDocM {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IDocM {
    let message: IDocM = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.x = view.readInt32();
          break;

        case 2:
          message.y = view.readInt32();
          break;

        case 3:
          message.z = view.readInt32();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

/**
 * Documented struct
 */
export interface IDocS {
  /**
   * Documented field
   */
  x: number;
}

export const DocS = {
  encode(message: IDocS): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IDocS, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.x);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IDocS {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IDocS {
    let field0: number;
    field0 = view.readInt32();
    let message: IDocS = {
      x: field0,
    };
    return message;
  },
};

export interface IBand {
  members: Array<IMusician>;
}

export const Band = {
  encode(message: IBand): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IBand, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.members.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          Musician.encodeInto(message.members[i0], view)
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IBand {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IBand {
    let field0: Array<IMusician>;
    {
      let length0 = view.readUint32();
      field0 = new Array<IMusician>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IMusician;
        x0 = Musician.readFrom(view);
        field0[i0] = x0;
      }
    }
    let message: IBand = {
      members: field0,
    };
    return message;
  },
};

export interface ISomething {
  imported: DocE;
}

export const Something = {
  encode(message: ISomething): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ISomething, view: BebopView): number {
    const before = view.length;
      view.writeEnum(message.imported);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ISomething {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ISomething {
    let field0: DocE;
    field0 = view.readUint32() as DocE;
    let message: ISomething = {
      imported: field0,
    };
    return message;
  },
};

export enum Instrument {
  Sax = 0,
  Trumpet = 1,
  Clarinet = 2,
}

/**
 * test
 */
export interface IMusician {
  /**
   * a name
   */
  readonly name: string;
  /**
   * an instrument
   */
  readonly plays: Instrument;
}

export const Musician = {
  opcode: 0x5A5A414A,
  encode(message: IMusician): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IMusician, view: BebopView): number {
    const before = view.length;
      view.writeString(message.name);
      view.writeEnum(message.plays);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IMusician {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IMusician {
    let field0: string;
    field0 = view.readString();
    let field1: Instrument;
    field1 = view.readUint32() as Instrument;
    let message: IMusician = {
      name: field0,
      plays: field1,
    };
    return message;
  },
};

export interface ISong {
  title?: string;
  year?: number;
  performers?: Array<IMusician>;
}

export const Song = {
  encode(message: ISong): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ISong, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.title != null) {
        view.writeByte(1);
        view.writeString(message.title);
      }
      if (message.year != null) {
        view.writeByte(2);
        view.writeUint16(message.year);
      }
      if (message.performers != null) {
        view.writeByte(3);
        {
        const length0 = message.performers.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          Musician.encodeInto(message.performers[i0], view)
        }
      }
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ISong {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ISong {
    let message: ISong = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.title = view.readString();
          break;

        case 2:
          message.year = view.readUint16();
          break;

        case 3:
          {
        let length0 = view.readUint32();
        message.performers = new Array<IMusician>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: IMusician;
          x0 = Musician.readFrom(view);
          message.performers[i0] = x0;
        }
      }
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface ILibrary {
  songs: Map<string, ISong>;
}

export const Library = {
  encode(message: ILibrary): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ILibrary, view: BebopView): number {
    const before = view.length;
      view.writeUint32(message.songs.size);
      for (const [k0, v0] of message.songs) {
        view.writeGuid(k0);
        Song.encodeInto(v0, view)
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ILibrary {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ILibrary {
    let field0: Map<string, ISong>;
    {
      let length0 = view.readUint32();
      field0 = new Map<string, ISong>();
      for (let i0 = 0; i0 < length0; i0++) {
        let k0: string;
        let v0: ISong;
        k0 = view.readGuid();
        v0 = Song.readFrom(view);
        field0.set(k0, v0);
      }
    }
    let message: ILibrary = {
      songs: field0,
    };
    return message;
  },
};

export interface IInt32s {
  a: Array<number>;
}

export const Int32s = {
  encode(message: IInt32s): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IInt32s, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.a.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeInt32(message.a[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IInt32s {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IInt32s {
    let field0: Array<number>;
    {
      let length0 = view.readUint32();
      field0 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readInt32();
        field0[i0] = x0;
      }
    }
    let message: IInt32s = {
      a: field0,
    };
    return message;
  },
};

export interface IUint32s {
  a: Array<number>;
}

export const Uint32s = {
  encode(message: IUint32s): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IUint32s, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.a.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeUint32(message.a[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IUint32s {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IUint32s {
    let field0: Array<number>;
    {
      let length0 = view.readUint32();
      field0 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readUint32();
        field0[i0] = x0;
      }
    }
    let message: IUint32s = {
      a: field0,
    };
    return message;
  },
};

export interface IFloat32s {
  a: Array<number>;
}

export const Float32s = {
  encode(message: IFloat32s): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IFloat32s, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.a.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeFloat32(message.a[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IFloat32s {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IFloat32s {
    let field0: Array<number>;
    {
      let length0 = view.readUint32();
      field0 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readFloat32();
        field0[i0] = x0;
      }
    }
    let message: IFloat32s = {
      a: field0,
    };
    return message;
  },
};

export interface IInt64s {
  a: Array<bigint>;
}

export const Int64s = {
  encode(message: IInt64s): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IInt64s, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.a.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeInt64(message.a[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IInt64s {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IInt64s {
    let field0: Array<bigint>;
    {
      let length0 = view.readUint32();
      field0 = new Array<bigint>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: bigint;
        x0 = view.readInt64();
        field0[i0] = x0;
      }
    }
    let message: IInt64s = {
      a: field0,
    };
    return message;
  },
};

export interface IUint64s {
  a: Array<bigint>;
}

export const Uint64s = {
  encode(message: IUint64s): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IUint64s, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.a.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeUint64(message.a[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IUint64s {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IUint64s {
    let field0: Array<bigint>;
    {
      let length0 = view.readUint32();
      field0 = new Array<bigint>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: bigint;
        x0 = view.readUint64();
        field0[i0] = x0;
      }
    }
    let message: IUint64s = {
      a: field0,
    };
    return message;
  },
};

export interface IFloat64s {
  a: Array<number>;
}

export const Float64s = {
  encode(message: IFloat64s): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IFloat64s, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.a.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeFloat64(message.a[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IFloat64s {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IFloat64s {
    let field0: Array<number>;
    {
      let length0 = view.readUint32();
      field0 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readFloat64();
        field0[i0] = x0;
      }
    }
    let message: IFloat64s = {
      a: field0,
    };
    return message;
  },
};

export enum VideoCodec {
  H264 = 0,
  H265 = 1,
}

export interface IVideoData {
  time: number;
  width: number;
  height: number;
  fragment: Uint8Array;
}

export const VideoData = {
  encode(message: IVideoData): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IVideoData, view: BebopView): number {
    const before = view.length;
      view.writeFloat64(message.time);
      view.writeUint32(message.width);
      view.writeUint32(message.height);
      view.writeBytes(message.fragment);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IVideoData {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IVideoData {
    let field0: number;
    field0 = view.readFloat64();
    let field1: number;
    field1 = view.readUint32();
    let field2: number;
    field2 = view.readUint32();
    let field3: Uint8Array;
    field3 = view.readBytes();
    let message: IVideoData = {
      time: field0,
      width: field1,
      height: field2,
      fragment: field3,
    };
    return message;
  },
};

export interface IMediaMessage {
  codec?: VideoCodec;
  data?: IVideoData;
}

export const MediaMessage = {
  encode(message: IMediaMessage): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IMediaMessage, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.codec != null) {
        view.writeByte(1);
        view.writeEnum(message.codec);
      }
      if (message.data != null) {
        view.writeByte(2);
        VideoData.encodeInto(message.data, view)
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IMediaMessage {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IMediaMessage {
    let message: IMediaMessage = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.codec = view.readUint32() as VideoCodec;
          break;

        case 2:
          message.data = VideoData.readFrom(view);
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface ISkipTestOld {
  x?: number;
  y?: number;
}

export const SkipTestOld = {
  encode(message: ISkipTestOld): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ISkipTestOld, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.x != null) {
        view.writeByte(1);
        view.writeInt32(message.x);
      }
      if (message.y != null) {
        view.writeByte(2);
        view.writeInt32(message.y);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ISkipTestOld {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ISkipTestOld {
    let message: ISkipTestOld = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.x = view.readInt32();
          break;

        case 2:
          message.y = view.readInt32();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface ISkipTestNew {
  x?: number;
  y?: number;
  z?: number;
}

export const SkipTestNew = {
  encode(message: ISkipTestNew): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ISkipTestNew, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.x != null) {
        view.writeByte(1);
        view.writeInt32(message.x);
      }
      if (message.y != null) {
        view.writeByte(2);
        view.writeInt32(message.y);
      }
      if (message.z != null) {
        view.writeByte(3);
        view.writeInt32(message.z);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ISkipTestNew {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ISkipTestNew {
    let message: ISkipTestNew = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.x = view.readInt32();
          break;

        case 2:
          message.y = view.readInt32();
          break;

        case 3:
          message.z = view.readInt32();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface ISkipTestOldContainer {
  s?: ISkipTestOld;
  after?: number;
}

export const SkipTestOldContainer = {
  encode(message: ISkipTestOldContainer): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ISkipTestOldContainer, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.s != null) {
        view.writeByte(1);
        SkipTestOld.encodeInto(message.s, view)
      }
      if (message.after != null) {
        view.writeByte(2);
        view.writeInt32(message.after);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ISkipTestOldContainer {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ISkipTestOldContainer {
    let message: ISkipTestOldContainer = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.s = SkipTestOld.readFrom(view);
          break;

        case 2:
          message.after = view.readInt32();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface ISkipTestNewContainer {
  s?: ISkipTestNew;
  after?: number;
}

export const SkipTestNewContainer = {
  encode(message: ISkipTestNewContainer): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ISkipTestNewContainer, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.s != null) {
        view.writeByte(1);
        SkipTestNew.encodeInto(message.s, view)
      }
      if (message.after != null) {
        view.writeByte(2);
        view.writeInt32(message.after);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ISkipTestNewContainer {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ISkipTestNewContainer {
    let message: ISkipTestNewContainer = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.s = SkipTestNew.readFrom(view);
          break;

        case 2:
          message.after = view.readInt32();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IM {
  a?: number;
  b?: number;
}

export const M = {
  encode(message: IM): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IM, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.a != null) {
        view.writeByte(1);
        view.writeFloat32(message.a);
      }
      if (message.b != null) {
        view.writeByte(2);
        view.writeFloat64(message.b);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IM {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IM {
    let message: IM = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.a = view.readFloat32();
          break;

        case 2:
          message.b = view.readFloat64();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IS {
  readonly x: number;
  readonly y: number;
}

export const S = {
  encode(message: IS): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IS, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.x);
      view.writeInt32(message.y);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IS {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IS {
    let field0: number;
    field0 = view.readInt32();
    let field1: number;
    field1 = view.readInt32();
    let message: IS = {
      x: field0,
      y: field1,
    };
    return message;
  },
};

export interface ISomeMaps {
  m1: Map<boolean, boolean>;
  m2: Map<string, Map<string, string>>;
  m3: Array<Map<number, Array<Map<boolean, IS>>>>;
  m4: Array<Map<string, Array<number>>>;
  m5: Map<string, IM>;
}

export const SomeMaps = {
  encode(message: ISomeMaps): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ISomeMaps, view: BebopView): number {
    const before = view.length;
      view.writeUint32(message.m1.size);
      for (const [k0, v0] of message.m1) {
        view.writeByte(Number(k0));
        view.writeByte(Number(v0));
      }
      view.writeUint32(message.m2.size);
      for (const [k0, v0] of message.m2) {
        view.writeString(k0);
        view.writeUint32(v0.size);
        for (const [k1, v1] of v0) {
          view.writeString(k1);
          view.writeString(v1);
        }
      }
      {
        const length0 = message.m3.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeUint32(message.m3[i0].size);
          for (const [k1, v1] of message.m3[i0]) {
            view.writeInt32(k1);
            {
              const length2 = v1.length;
              view.writeUint32(length2);
              for (let i2 = 0; i2 < length2; i2++) {
                view.writeUint32(v1[i2].size);
                for (const [k3, v3] of v1[i2]) {
                  view.writeByte(Number(k3));
                  S.encodeInto(v3, view)
                }
              }
            }
          }
        }
      }
      {
        const length0 = message.m4.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeUint32(message.m4[i0].size);
          for (const [k1, v1] of message.m4[i0]) {
            view.writeString(k1);
            {
              const length2 = v1.length;
              view.writeUint32(length2);
              for (let i2 = 0; i2 < length2; i2++) {
                view.writeFloat32(v1[i2]);
              }
            }
          }
        }
      }
      view.writeUint32(message.m5.size);
      for (const [k0, v0] of message.m5) {
        view.writeGuid(k0);
        M.encodeInto(v0, view)
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ISomeMaps {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ISomeMaps {
    let field0: Map<boolean, boolean>;
    {
      let length0 = view.readUint32();
      field0 = new Map<boolean, boolean>();
      for (let i0 = 0; i0 < length0; i0++) {
        let k0: boolean;
        let v0: boolean;
        k0 = !!view.readByte();
        v0 = !!view.readByte();
        field0.set(k0, v0);
      }
    }
    let field1: Map<string, Map<string, string>>;
    {
      let length0 = view.readUint32();
      field1 = new Map<string, Map<string, string>>();
      for (let i0 = 0; i0 < length0; i0++) {
        let k0: string;
        let v0: Map<string, string>;
        k0 = view.readString();
        {
          let length1 = view.readUint32();
          v0 = new Map<string, string>();
          for (let i1 = 0; i1 < length1; i1++) {
            let k1: string;
            let v1: string;
            k1 = view.readString();
            v1 = view.readString();
            v0.set(k1, v1);
          }
        }
        field1.set(k0, v0);
      }
    }
    let field2: Array<Map<number, Array<Map<boolean, IS>>>>;
    {
      let length0 = view.readUint32();
      field2 = new Array<Map<number, Array<Map<boolean, IS>>>>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Map<number, Array<Map<boolean, IS>>>;
        {
          let length1 = view.readUint32();
          x0 = new Map<number, Array<Map<boolean, IS>>>();
          for (let i1 = 0; i1 < length1; i1++) {
            let k1: number;
            let v1: Array<Map<boolean, IS>>;
            k1 = view.readInt32();
            {
              let length2 = view.readUint32();
              v1 = new Array<Map<boolean, IS>>(length2);
              for (let i2 = 0; i2 < length2; i2++) {
                let x2: Map<boolean, IS>;
                {
                  let length3 = view.readUint32();
                  x2 = new Map<boolean, IS>();
                  for (let i3 = 0; i3 < length3; i3++) {
                    let k3: boolean;
                    let v3: IS;
                    k3 = !!view.readByte();
                    v3 = S.readFrom(view);
                    x2.set(k3, v3);
                  }
                }
                v1[i2] = x2;
              }
            }
            x0.set(k1, v1);
          }
        }
        field2[i0] = x0;
      }
    }
    let field3: Array<Map<string, Array<number>>>;
    {
      let length0 = view.readUint32();
      field3 = new Array<Map<string, Array<number>>>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: Map<string, Array<number>>;
        {
          let length1 = view.readUint32();
          x0 = new Map<string, Array<number>>();
          for (let i1 = 0; i1 < length1; i1++) {
            let k1: string;
            let v1: Array<number>;
            k1 = view.readString();
            {
              let length2 = view.readUint32();
              v1 = new Array<number>(length2);
              for (let i2 = 0; i2 < length2; i2++) {
                let x2: number;
                x2 = view.readFloat32();
                v1[i2] = x2;
              }
            }
            x0.set(k1, v1);
          }
        }
        field3[i0] = x0;
      }
    }
    let field4: Map<string, IM>;
    {
      let length0 = view.readUint32();
      field4 = new Map<string, IM>();
      for (let i0 = 0; i0 < length0; i0++) {
        let k0: string;
        let v0: IM;
        k0 = view.readGuid();
        v0 = M.readFrom(view);
        field4.set(k0, v0);
      }
    }
    let message: ISomeMaps = {
      m1: field0,
      m2: field1,
      m3: field2,
      m4: field3,
      m5: field4,
    };
    return message;
  },
};

export interface IMsgpackComparison {
  ant0: number;
  ant1: number;
  ant1X: number;
  ant8: number;
  ant8X: number;
  ant16: number;
  ant16X: number;
  ant32: number;
  ant32X: number;
  arue: boolean;
  aalse: boolean;
  aloat: number;
  aloatx: number;
  atring0: string;
  atring1: string;
  atring4: string;
  atring8: string;
  atring16: string;
  array0: Array<number>;
  array1: Array<string>;
  array8: Array<number>;
}

export const MsgpackComparison = {
  encode(message: IMsgpackComparison): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IMsgpackComparison, view: BebopView): number {
    const before = view.length;
      view.writeByte(message.ant0);
      view.writeByte(message.ant1);
      view.writeInt16(message.ant1X);
      view.writeByte(message.ant8);
      view.writeInt16(message.ant8X);
      view.writeInt16(message.ant16);
      view.writeInt16(message.ant16X);
      view.writeInt32(message.ant32);
      view.writeInt32(message.ant32X);
      view.writeByte(Number(message.arue));
      view.writeByte(Number(message.aalse));
      view.writeFloat64(message.aloat);
      view.writeFloat64(message.aloatx);
      view.writeString(message.atring0);
      view.writeString(message.atring1);
      view.writeString(message.atring4);
      view.writeString(message.atring8);
      view.writeString(message.atring16);
      {
        const length0 = message.array0.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeInt32(message.array0[i0]);
        }
      }
      {
        const length0 = message.array1.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeString(message.array1[i0]);
        }
      }
      {
        const length0 = message.array8.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeInt32(message.array8[i0]);
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IMsgpackComparison {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IMsgpackComparison {
    let field0: number;
    field0 = view.readByte();
    let field1: number;
    field1 = view.readByte();
    let field2: number;
    field2 = view.readInt16();
    let field3: number;
    field3 = view.readByte();
    let field4: number;
    field4 = view.readInt16();
    let field5: number;
    field5 = view.readInt16();
    let field6: number;
    field6 = view.readInt16();
    let field7: number;
    field7 = view.readInt32();
    let field8: number;
    field8 = view.readInt32();
    let field9: boolean;
    field9 = !!view.readByte();
    let field10: boolean;
    field10 = !!view.readByte();
    let field11: number;
    field11 = view.readFloat64();
    let field12: number;
    field12 = view.readFloat64();
    let field13: string;
    field13 = view.readString();
    let field14: string;
    field14 = view.readString();
    let field15: string;
    field15 = view.readString();
    let field16: string;
    field16 = view.readString();
    let field17: string;
    field17 = view.readString();
    let field18: Array<number>;
    {
      let length0 = view.readUint32();
      field18 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readInt32();
        field18[i0] = x0;
      }
    }
    let field19: Array<string>;
    {
      let length0 = view.readUint32();
      field19 = new Array<string>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: string;
        x0 = view.readString();
        field19[i0] = x0;
      }
    }
    let field20: Array<number>;
    {
      let length0 = view.readUint32();
      field20 = new Array<number>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: number;
        x0 = view.readInt32();
        field20[i0] = x0;
      }
    }
    let message: IMsgpackComparison = {
      ant0: field0,
      ant1: field1,
      ant1X: field2,
      ant8: field3,
      ant8X: field4,
      ant16: field5,
      ant16X: field6,
      ant32: field7,
      ant32X: field8,
      arue: field9,
      aalse: field10,
      aloat: field11,
      aloatx: field12,
      atring0: field13,
      atring1: field14,
      atring4: field15,
      atring8: field16,
      atring16: field17,
      array0: field18,
      array1: field19,
      array8: field20,
    };
    return message;
  },
};

export interface IInnerM {
  x?: number;
}

export const InnerM = {
  encode(message: IInnerM): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IInnerM, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.x != null) {
        view.writeByte(1);
        view.writeInt32(message.x);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IInnerM {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IInnerM {
    let message: IInnerM = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.x = view.readInt32();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IInnerS {
  y: boolean;
}

export const InnerS = {
  encode(message: IInnerS): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IInnerS, view: BebopView): number {
    const before = view.length;
      view.writeByte(Number(message.y));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IInnerS {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IInnerS {
    let field0: boolean;
    field0 = !!view.readByte();
    let message: IInnerS = {
      y: field0,
    };
    return message;
  },
};

export interface IOuterM {
  innerM?: IInnerM;
  innerS?: IInnerS;
}

export const OuterM = {
  encode(message: IOuterM): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IOuterM, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.innerM != null) {
        view.writeByte(1);
        InnerM.encodeInto(message.innerM, view)
      }
      if (message.innerS != null) {
        view.writeByte(2);
        InnerS.encodeInto(message.innerS, view)
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IOuterM {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IOuterM {
    let message: IOuterM = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.innerM = InnerM.readFrom(view);
          break;

        case 2:
          message.innerS = InnerS.readFrom(view);
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IOuterS {
  innerM: IInnerM;
  innerS: IInnerS;
}

export const OuterS = {
  encode(message: IOuterS): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IOuterS, view: BebopView): number {
    const before = view.length;
      InnerM.encodeInto(message.innerM, view)
      InnerS.encodeInto(message.innerS, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IOuterS {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IOuterS {
    let field0: IInnerM;
    field0 = InnerM.readFrom(view);
    let field1: IInnerS;
    field1 = InnerS.readFrom(view);
    let message: IOuterS = {
      innerM: field0,
      innerS: field1,
    };
    return message;
  },
};

export enum FurnitureFamily {
  Bed = 0,
  Table = 1,
  Shoe = 2,
}

export interface IFurniture {
  readonly name: string;
  readonly price: number;
  readonly family: FurnitureFamily;
}

export const Furniture = {
  encode(message: IFurniture): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IFurniture, view: BebopView): number {
    const before = view.length;
      view.writeString(message.name);
      view.writeUint32(message.price);
      view.writeEnum(message.family);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IFurniture {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IFurniture {
    let field0: string;
    field0 = view.readString();
    let field1: number;
    field1 = view.readUint32();
    let field2: FurnitureFamily;
    field2 = view.readUint32() as FurnitureFamily;
    let message: IFurniture = {
      name: field0,
      price: field1,
      family: field2,
    };
    return message;
  },
};

export interface IRequestCatalog {
  family?: FurnitureFamily;
  /**
   * @deprecated Nobody react to what I'm about to say...
   */
  secretTunnel?: string;
}

export const RequestCatalog = {
  opcode: 0x41454B49,
  encode(message: IRequestCatalog): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IRequestCatalog, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.family != null) {
        view.writeByte(1);
        view.writeEnum(message.family);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IRequestCatalog {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IRequestCatalog {
    let message: IRequestCatalog = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.family = view.readUint32() as FurnitureFamily;
          break;

        case 2:
          message.secretTunnel = view.readString();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

export interface IRequestResponse {
  readonly availableFurniture: Array<IFurniture>;
}

export const RequestResponse = {
  opcode: 0x31323334,
  encode(message: IRequestResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IRequestResponse, view: BebopView): number {
    const before = view.length;
      {
        const length0 = message.availableFurniture.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          Furniture.encodeInto(message.availableFurniture[i0], view)
        }
      }
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IRequestResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IRequestResponse {
    let field0: Array<IFurniture>;
    {
      let length0 = view.readUint32();
      field0 = new Array<IFurniture>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IFurniture;
        x0 = Furniture.readFrom(view);
        field0[i0] = x0;
      }
    }
    let message: IRequestResponse = {
      availableFurniture: field0,
    };
    return message;
  },
};

export interface IToposort7 {
  x: IToposort6;
}

export const Toposort7 = {
  encode(message: IToposort7): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort7, view: BebopView): number {
    const before = view.length;
      Toposort6.encodeInto(message.x, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort7 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort7 {
    let field0: IToposort6;
    field0 = Toposort6.readFrom(view);
    let message: IToposort7 = {
      x: field0,
    };
    return message;
  },
};

export interface IToposort2 {
  x: IToposort1;
}

export const Toposort2 = {
  encode(message: IToposort2): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort2, view: BebopView): number {
    const before = view.length;
      Toposort1.encodeInto(message.x, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort2 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort2 {
    let field0: IToposort1;
    field0 = Toposort1.readFrom(view);
    let message: IToposort2 = {
      x: field0,
    };
    return message;
  },
};

export interface IToposort9 {
  x: IToposort8;
}

export const Toposort9 = {
  encode(message: IToposort9): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort9, view: BebopView): number {
    const before = view.length;
      Toposort8.encodeInto(message.x, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort9 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort9 {
    let field0: IToposort8;
    field0 = Toposort8.readFrom(view);
    let message: IToposort9 = {
      x: field0,
    };
    return message;
  },
};

export interface IToposort0 {
  x: number;
}

export const Toposort0 = {
  encode(message: IToposort0): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort0, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.x);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort0 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort0 {
    let field0: number;
    field0 = view.readInt32();
    let message: IToposort0 = {
      x: field0,
    };
    return message;
  },
};

export interface IToposort5 {
  x: IToposort4;
}

export const Toposort5 = {
  encode(message: IToposort5): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort5, view: BebopView): number {
    const before = view.length;
      Toposort4.encodeInto(message.x, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort5 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort5 {
    let field0: IToposort4;
    field0 = Toposort4.readFrom(view);
    let message: IToposort5 = {
      x: field0,
    };
    return message;
  },
};

export interface IToposort1 {
  x: IToposort0;
}

export const Toposort1 = {
  encode(message: IToposort1): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort1, view: BebopView): number {
    const before = view.length;
      Toposort0.encodeInto(message.x, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort1 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort1 {
    let field0: IToposort0;
    field0 = Toposort0.readFrom(view);
    let message: IToposort1 = {
      x: field0,
    };
    return message;
  },
};

export interface IToposort6 {
  x: IToposort5;
}

export const Toposort6 = {
  encode(message: IToposort6): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort6, view: BebopView): number {
    const before = view.length;
      Toposort5.encodeInto(message.x, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort6 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort6 {
    let field0: IToposort5;
    field0 = Toposort5.readFrom(view);
    let message: IToposort6 = {
      x: field0,
    };
    return message;
  },
};

export interface IToposort4 {
  x: IToposort3;
}

export const Toposort4 = {
  encode(message: IToposort4): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort4, view: BebopView): number {
    const before = view.length;
      Toposort3.encodeInto(message.x, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort4 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort4 {
    let field0: IToposort3;
    field0 = Toposort3.readFrom(view);
    let message: IToposort4 = {
      x: field0,
    };
    return message;
  },
};

export interface IToposort3 {
  x: IToposort2;
}

export const Toposort3 = {
  encode(message: IToposort3): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort3, view: BebopView): number {
    const before = view.length;
      Toposort2.encodeInto(message.x, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort3 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort3 {
    let field0: IToposort2;
    field0 = Toposort2.readFrom(view);
    let message: IToposort3 = {
      x: field0,
    };
    return message;
  },
};

export interface IToposort8 {
  x: IToposort7;
}

export const Toposort8 = {
  encode(message: IToposort8): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IToposort8, view: BebopView): number {
    const before = view.length;
      Toposort7.encodeInto(message.x, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IToposort8 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IToposort8 {
    let field0: IToposort7;
    field0 = Toposort7.readFrom(view);
    let message: IToposort8 = {
      x: field0,
    };
    return message;
  },
};

export interface IA {
  b?: number;
}

export const A = {
  discriminator: 1 as 1,
  encode(message: IA): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length;
      if (message.b != null) {
        view.writeByte(1);
        view.writeUint32(message.b);
      }
      view.writeByte(0);
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA {
    let message: IA = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return message;

        case 1:
          message.b = view.readUint32();
          break;

        default:
          view.index = end;
          return message;
      }
    }
  },
};

/**
 * This branch is, too!
 */
export interface IB {
  c: boolean;
}

export const B = {
  discriminator: 2 as 2,
  encode(message: IB): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB, view: BebopView): number {
    const before = view.length;
      view.writeByte(Number(message.c));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB {
    let field0: boolean;
    field0 = !!view.readByte();
    let message: IB = {
      c: field0,
    };
    return message;
  },
};

export interface IC {
}

export const C = {
  discriminator: 3 as 3,
  encode(message: IC): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IC, view: BebopView): number {
    const before = view.length;

    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IC {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IC {
    let message: IC = {
    };
    return message;
  },
};

/**
 * This union is so documented!
 */
export type IU
  = { discriminator: 1, value: IA }
  | { discriminator: 2, value: IB }
  | { discriminator: 3, value: IC };

export const U = {
  opcode: 0x68616579,
  encode(message: IU): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IU, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length + 1;
      view.writeByte(message.discriminator);
      switch (message.discriminator) {
        case 1:
          A.encodeInto(message.value, view);
          break;
        case 2:
          B.encodeInto(message.value, view);
          break;
        case 3:
          C.encodeInto(message.value, view);
          break;
      }
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IU {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IU {
    const length = view.readMessageLength();
    const end = view.index + 1 + length;
    switch (view.readByte()) {
      case 1:
        return { discriminator: 1, value: A.readFrom(view) };
      case 2:
        return { discriminator: 2, value: B.readFrom(view) };
      case 3:
        return { discriminator: 3, value: C.readFrom(view) };
      default:
        view.index = end;
        throw new BebopRuntimeError("Unrecognized discriminator while decoding U");
    }
  },
};

export interface ITwoComesFirst {
  b: number;
}

export const TwoComesFirst = {
  discriminator: 2 as 2,
  encode(message: ITwoComesFirst): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ITwoComesFirst, view: BebopView): number {
    const before = view.length;
      view.writeByte(message.b);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ITwoComesFirst {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ITwoComesFirst {
    let field0: number;
    field0 = view.readByte();
    let message: ITwoComesFirst = {
      b: field0,
    };
    return message;
  },
};

export interface IThreeIsSkipped {
}

export const ThreeIsSkipped = {
  discriminator: 4 as 4,
  encode(message: IThreeIsSkipped): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IThreeIsSkipped, view: BebopView): number {
    const before = view.length;

    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IThreeIsSkipped {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IThreeIsSkipped {
    let message: IThreeIsSkipped = {
    };
    return message;
  },
};

export interface IOneComesLast {
}

export const OneComesLast = {
  discriminator: 1 as 1,
  encode(message: IOneComesLast): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IOneComesLast, view: BebopView): number {
    const before = view.length;

    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IOneComesLast {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IOneComesLast {
    let message: IOneComesLast = {
    };
    return message;
  },
};

export type IWeirdOrder
  = { discriminator: 2, value: ITwoComesFirst }
  | { discriminator: 4, value: IThreeIsSkipped }
  | { discriminator: 1, value: IOneComesLast };

export const WeirdOrder = {
  encode(message: IWeirdOrder): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IWeirdOrder, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length + 1;
      view.writeByte(message.discriminator);
      switch (message.discriminator) {
        case 2:
          TwoComesFirst.encodeInto(message.value, view);
          break;
        case 4:
          ThreeIsSkipped.encodeInto(message.value, view);
          break;
        case 1:
          OneComesLast.encodeInto(message.value, view);
          break;
      }
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IWeirdOrder {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IWeirdOrder {
    const length = view.readMessageLength();
    const end = view.index + 1 + length;
    switch (view.readByte()) {
      case 2:
        return { discriminator: 2, value: TwoComesFirst.readFrom(view) };
      case 4:
        return { discriminator: 4, value: ThreeIsSkipped.readFrom(view) };
      case 1:
        return { discriminator: 1, value: OneComesLast.readFrom(view) };
      default:
        view.index = end;
        throw new BebopRuntimeError("Unrecognized discriminator while decoding WeirdOrder");
    }
  },
};

export interface IA1 {
  i1: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A1 = {
  discriminator: 1 as 1,
  encode(message: IA1): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA1, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i1);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA1 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA1 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA1 = {
      i1: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA2 {
  i2: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A2 = {
  discriminator: 2 as 2,
  encode(message: IA2): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA2, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i2);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA2 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA2 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA2 = {
      i2: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA3 {
  i3: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A3 = {
  discriminator: 3 as 3,
  encode(message: IA3): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA3, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i3);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA3 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA3 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA3 = {
      i3: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA4 {
  i4: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A4 = {
  discriminator: 4 as 4,
  encode(message: IA4): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA4, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i4);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA4 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA4 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA4 = {
      i4: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA5 {
  i5: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A5 = {
  discriminator: 5 as 5,
  encode(message: IA5): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA5, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i5);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA5 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA5 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA5 = {
      i5: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA6 {
  i6: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A6 = {
  discriminator: 6 as 6,
  encode(message: IA6): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA6, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i6);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA6 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA6 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA6 = {
      i6: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA7 {
  i7: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A7 = {
  discriminator: 7 as 7,
  encode(message: IA7): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA7, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i7);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA7 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA7 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA7 = {
      i7: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA8 {
  i8: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A8 = {
  discriminator: 8 as 8,
  encode(message: IA8): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA8, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i8);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA8 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA8 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA8 = {
      i8: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA9 {
  i9: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A9 = {
  discriminator: 9 as 9,
  encode(message: IA9): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA9, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i9);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA9 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA9 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA9 = {
      i9: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA10 {
  i10: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A10 = {
  discriminator: 10 as 10,
  encode(message: IA10): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA10, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i10);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA10 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA10 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA10 = {
      i10: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA11 {
  i11: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A11 = {
  discriminator: 11 as 11,
  encode(message: IA11): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA11, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i11);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA11 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA11 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA11 = {
      i11: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA12 {
  i12: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A12 = {
  discriminator: 12 as 12,
  encode(message: IA12): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA12, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i12);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA12 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA12 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA12 = {
      i12: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA13 {
  i13: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A13 = {
  discriminator: 13 as 13,
  encode(message: IA13): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA13, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i13);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA13 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA13 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA13 = {
      i13: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA14 {
  i14: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A14 = {
  discriminator: 14 as 14,
  encode(message: IA14): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA14, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i14);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA14 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA14 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA14 = {
      i14: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA15 {
  i15: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A15 = {
  discriminator: 15 as 15,
  encode(message: IA15): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA15, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i15);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA15 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA15 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA15 = {
      i15: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA16 {
  i16: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A16 = {
  discriminator: 16 as 16,
  encode(message: IA16): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA16, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i16);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA16 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA16 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA16 = {
      i16: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA17 {
  i17: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A17 = {
  discriminator: 17 as 17,
  encode(message: IA17): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA17, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i17);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA17 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA17 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA17 = {
      i17: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA18 {
  i18: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A18 = {
  discriminator: 18 as 18,
  encode(message: IA18): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA18, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i18);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA18 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA18 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA18 = {
      i18: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA19 {
  i19: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A19 = {
  discriminator: 19 as 19,
  encode(message: IA19): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA19, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i19);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA19 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA19 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA19 = {
      i19: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA20 {
  i20: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A20 = {
  discriminator: 20 as 20,
  encode(message: IA20): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA20, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i20);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA20 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA20 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA20 = {
      i20: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA21 {
  i21: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A21 = {
  discriminator: 21 as 21,
  encode(message: IA21): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA21, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i21);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA21 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA21 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA21 = {
      i21: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA22 {
  i22: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A22 = {
  discriminator: 22 as 22,
  encode(message: IA22): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA22, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i22);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA22 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA22 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA22 = {
      i22: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA23 {
  i23: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A23 = {
  discriminator: 23 as 23,
  encode(message: IA23): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA23, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i23);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA23 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA23 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA23 = {
      i23: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA24 {
  i24: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A24 = {
  discriminator: 24 as 24,
  encode(message: IA24): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA24, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i24);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA24 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA24 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA24 = {
      i24: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA25 {
  i25: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A25 = {
  discriminator: 25 as 25,
  encode(message: IA25): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA25, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i25);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA25 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA25 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA25 = {
      i25: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA26 {
  i26: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A26 = {
  discriminator: 26 as 26,
  encode(message: IA26): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA26, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i26);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA26 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA26 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA26 = {
      i26: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA27 {
  i27: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A27 = {
  discriminator: 27 as 27,
  encode(message: IA27): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA27, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i27);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA27 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA27 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA27 = {
      i27: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA28 {
  i28: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A28 = {
  discriminator: 28 as 28,
  encode(message: IA28): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA28, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i28);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA28 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA28 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA28 = {
      i28: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA29 {
  i29: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A29 = {
  discriminator: 29 as 29,
  encode(message: IA29): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA29, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i29);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA29 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA29 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA29 = {
      i29: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA30 {
  i30: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A30 = {
  discriminator: 30 as 30,
  encode(message: IA30): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA30, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i30);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA30 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA30 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA30 = {
      i30: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA31 {
  i31: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A31 = {
  discriminator: 31 as 31,
  encode(message: IA31): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA31, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i31);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA31 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA31 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA31 = {
      i31: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA32 {
  i32: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A32 = {
  discriminator: 32 as 32,
  encode(message: IA32): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA32, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i32);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA32 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA32 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA32 = {
      i32: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA33 {
  i33: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A33 = {
  discriminator: 33 as 33,
  encode(message: IA33): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA33, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i33);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA33 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA33 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA33 = {
      i33: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA34 {
  i34: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A34 = {
  discriminator: 34 as 34,
  encode(message: IA34): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA34, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i34);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA34 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA34 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA34 = {
      i34: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA35 {
  i35: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A35 = {
  discriminator: 35 as 35,
  encode(message: IA35): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA35, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i35);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA35 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA35 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA35 = {
      i35: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA36 {
  i36: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A36 = {
  discriminator: 36 as 36,
  encode(message: IA36): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA36, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i36);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA36 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA36 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA36 = {
      i36: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA37 {
  i37: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A37 = {
  discriminator: 37 as 37,
  encode(message: IA37): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA37, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i37);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA37 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA37 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA37 = {
      i37: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA38 {
  i38: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A38 = {
  discriminator: 38 as 38,
  encode(message: IA38): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA38, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i38);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA38 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA38 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA38 = {
      i38: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA39 {
  i39: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A39 = {
  discriminator: 39 as 39,
  encode(message: IA39): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA39, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i39);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA39 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA39 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA39 = {
      i39: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA40 {
  i40: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A40 = {
  discriminator: 40 as 40,
  encode(message: IA40): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA40, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i40);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA40 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA40 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA40 = {
      i40: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA41 {
  i41: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A41 = {
  discriminator: 41 as 41,
  encode(message: IA41): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA41, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i41);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA41 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA41 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA41 = {
      i41: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA42 {
  i42: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A42 = {
  discriminator: 42 as 42,
  encode(message: IA42): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA42, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i42);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA42 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA42 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA42 = {
      i42: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA43 {
  i43: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A43 = {
  discriminator: 43 as 43,
  encode(message: IA43): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA43, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i43);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA43 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA43 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA43 = {
      i43: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA44 {
  i44: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A44 = {
  discriminator: 44 as 44,
  encode(message: IA44): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA44, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i44);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA44 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA44 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA44 = {
      i44: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA45 {
  i45: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A45 = {
  discriminator: 45 as 45,
  encode(message: IA45): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA45, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i45);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA45 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA45 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA45 = {
      i45: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA46 {
  i46: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A46 = {
  discriminator: 46 as 46,
  encode(message: IA46): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA46, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i46);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA46 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA46 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA46 = {
      i46: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA47 {
  i47: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A47 = {
  discriminator: 47 as 47,
  encode(message: IA47): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA47, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i47);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA47 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA47 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA47 = {
      i47: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA48 {
  i48: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A48 = {
  discriminator: 48 as 48,
  encode(message: IA48): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA48, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i48);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA48 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA48 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA48 = {
      i48: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA49 {
  i49: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A49 = {
  discriminator: 49 as 49,
  encode(message: IA49): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA49, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i49);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA49 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA49 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA49 = {
      i49: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IA50 {
  i50: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const A50 = {
  discriminator: 50 as 50,
  encode(message: IA50): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IA50, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i50);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IA50 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IA50 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IA50 = {
      i50: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

/**
 * Option A: put the whole thing in a union.
 */
export type IUnionPerfU
  = { discriminator: 1, value: IA1 }
  | { discriminator: 2, value: IA2 }
  | { discriminator: 3, value: IA3 }
  | { discriminator: 4, value: IA4 }
  | { discriminator: 5, value: IA5 }
  | { discriminator: 6, value: IA6 }
  | { discriminator: 7, value: IA7 }
  | { discriminator: 8, value: IA8 }
  | { discriminator: 9, value: IA9 }
  | { discriminator: 10, value: IA10 }
  | { discriminator: 11, value: IA11 }
  | { discriminator: 12, value: IA12 }
  | { discriminator: 13, value: IA13 }
  | { discriminator: 14, value: IA14 }
  | { discriminator: 15, value: IA15 }
  | { discriminator: 16, value: IA16 }
  | { discriminator: 17, value: IA17 }
  | { discriminator: 18, value: IA18 }
  | { discriminator: 19, value: IA19 }
  | { discriminator: 20, value: IA20 }
  | { discriminator: 21, value: IA21 }
  | { discriminator: 22, value: IA22 }
  | { discriminator: 23, value: IA23 }
  | { discriminator: 24, value: IA24 }
  | { discriminator: 25, value: IA25 }
  | { discriminator: 26, value: IA26 }
  | { discriminator: 27, value: IA27 }
  | { discriminator: 28, value: IA28 }
  | { discriminator: 29, value: IA29 }
  | { discriminator: 30, value: IA30 }
  | { discriminator: 31, value: IA31 }
  | { discriminator: 32, value: IA32 }
  | { discriminator: 33, value: IA33 }
  | { discriminator: 34, value: IA34 }
  | { discriminator: 35, value: IA35 }
  | { discriminator: 36, value: IA36 }
  | { discriminator: 37, value: IA37 }
  | { discriminator: 38, value: IA38 }
  | { discriminator: 39, value: IA39 }
  | { discriminator: 40, value: IA40 }
  | { discriminator: 41, value: IA41 }
  | { discriminator: 42, value: IA42 }
  | { discriminator: 43, value: IA43 }
  | { discriminator: 44, value: IA44 }
  | { discriminator: 45, value: IA45 }
  | { discriminator: 46, value: IA46 }
  | { discriminator: 47, value: IA47 }
  | { discriminator: 48, value: IA48 }
  | { discriminator: 49, value: IA49 }
  | { discriminator: 50, value: IA50 };

export const UnionPerfU = {
  encode(message: IUnionPerfU): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IUnionPerfU, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length + 1;
      view.writeByte(message.discriminator);
      switch (message.discriminator) {
        case 1:
          A1.encodeInto(message.value, view);
          break;
        case 2:
          A2.encodeInto(message.value, view);
          break;
        case 3:
          A3.encodeInto(message.value, view);
          break;
        case 4:
          A4.encodeInto(message.value, view);
          break;
        case 5:
          A5.encodeInto(message.value, view);
          break;
        case 6:
          A6.encodeInto(message.value, view);
          break;
        case 7:
          A7.encodeInto(message.value, view);
          break;
        case 8:
          A8.encodeInto(message.value, view);
          break;
        case 9:
          A9.encodeInto(message.value, view);
          break;
        case 10:
          A10.encodeInto(message.value, view);
          break;
        case 11:
          A11.encodeInto(message.value, view);
          break;
        case 12:
          A12.encodeInto(message.value, view);
          break;
        case 13:
          A13.encodeInto(message.value, view);
          break;
        case 14:
          A14.encodeInto(message.value, view);
          break;
        case 15:
          A15.encodeInto(message.value, view);
          break;
        case 16:
          A16.encodeInto(message.value, view);
          break;
        case 17:
          A17.encodeInto(message.value, view);
          break;
        case 18:
          A18.encodeInto(message.value, view);
          break;
        case 19:
          A19.encodeInto(message.value, view);
          break;
        case 20:
          A20.encodeInto(message.value, view);
          break;
        case 21:
          A21.encodeInto(message.value, view);
          break;
        case 22:
          A22.encodeInto(message.value, view);
          break;
        case 23:
          A23.encodeInto(message.value, view);
          break;
        case 24:
          A24.encodeInto(message.value, view);
          break;
        case 25:
          A25.encodeInto(message.value, view);
          break;
        case 26:
          A26.encodeInto(message.value, view);
          break;
        case 27:
          A27.encodeInto(message.value, view);
          break;
        case 28:
          A28.encodeInto(message.value, view);
          break;
        case 29:
          A29.encodeInto(message.value, view);
          break;
        case 30:
          A30.encodeInto(message.value, view);
          break;
        case 31:
          A31.encodeInto(message.value, view);
          break;
        case 32:
          A32.encodeInto(message.value, view);
          break;
        case 33:
          A33.encodeInto(message.value, view);
          break;
        case 34:
          A34.encodeInto(message.value, view);
          break;
        case 35:
          A35.encodeInto(message.value, view);
          break;
        case 36:
          A36.encodeInto(message.value, view);
          break;
        case 37:
          A37.encodeInto(message.value, view);
          break;
        case 38:
          A38.encodeInto(message.value, view);
          break;
        case 39:
          A39.encodeInto(message.value, view);
          break;
        case 40:
          A40.encodeInto(message.value, view);
          break;
        case 41:
          A41.encodeInto(message.value, view);
          break;
        case 42:
          A42.encodeInto(message.value, view);
          break;
        case 43:
          A43.encodeInto(message.value, view);
          break;
        case 44:
          A44.encodeInto(message.value, view);
          break;
        case 45:
          A45.encodeInto(message.value, view);
          break;
        case 46:
          A46.encodeInto(message.value, view);
          break;
        case 47:
          A47.encodeInto(message.value, view);
          break;
        case 48:
          A48.encodeInto(message.value, view);
          break;
        case 49:
          A49.encodeInto(message.value, view);
          break;
        case 50:
          A50.encodeInto(message.value, view);
          break;
      }
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IUnionPerfU {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IUnionPerfU {
    const length = view.readMessageLength();
    const end = view.index + 1 + length;
    switch (view.readByte()) {
      case 1:
        return { discriminator: 1, value: A1.readFrom(view) };
      case 2:
        return { discriminator: 2, value: A2.readFrom(view) };
      case 3:
        return { discriminator: 3, value: A3.readFrom(view) };
      case 4:
        return { discriminator: 4, value: A4.readFrom(view) };
      case 5:
        return { discriminator: 5, value: A5.readFrom(view) };
      case 6:
        return { discriminator: 6, value: A6.readFrom(view) };
      case 7:
        return { discriminator: 7, value: A7.readFrom(view) };
      case 8:
        return { discriminator: 8, value: A8.readFrom(view) };
      case 9:
        return { discriminator: 9, value: A9.readFrom(view) };
      case 10:
        return { discriminator: 10, value: A10.readFrom(view) };
      case 11:
        return { discriminator: 11, value: A11.readFrom(view) };
      case 12:
        return { discriminator: 12, value: A12.readFrom(view) };
      case 13:
        return { discriminator: 13, value: A13.readFrom(view) };
      case 14:
        return { discriminator: 14, value: A14.readFrom(view) };
      case 15:
        return { discriminator: 15, value: A15.readFrom(view) };
      case 16:
        return { discriminator: 16, value: A16.readFrom(view) };
      case 17:
        return { discriminator: 17, value: A17.readFrom(view) };
      case 18:
        return { discriminator: 18, value: A18.readFrom(view) };
      case 19:
        return { discriminator: 19, value: A19.readFrom(view) };
      case 20:
        return { discriminator: 20, value: A20.readFrom(view) };
      case 21:
        return { discriminator: 21, value: A21.readFrom(view) };
      case 22:
        return { discriminator: 22, value: A22.readFrom(view) };
      case 23:
        return { discriminator: 23, value: A23.readFrom(view) };
      case 24:
        return { discriminator: 24, value: A24.readFrom(view) };
      case 25:
        return { discriminator: 25, value: A25.readFrom(view) };
      case 26:
        return { discriminator: 26, value: A26.readFrom(view) };
      case 27:
        return { discriminator: 27, value: A27.readFrom(view) };
      case 28:
        return { discriminator: 28, value: A28.readFrom(view) };
      case 29:
        return { discriminator: 29, value: A29.readFrom(view) };
      case 30:
        return { discriminator: 30, value: A30.readFrom(view) };
      case 31:
        return { discriminator: 31, value: A31.readFrom(view) };
      case 32:
        return { discriminator: 32, value: A32.readFrom(view) };
      case 33:
        return { discriminator: 33, value: A33.readFrom(view) };
      case 34:
        return { discriminator: 34, value: A34.readFrom(view) };
      case 35:
        return { discriminator: 35, value: A35.readFrom(view) };
      case 36:
        return { discriminator: 36, value: A36.readFrom(view) };
      case 37:
        return { discriminator: 37, value: A37.readFrom(view) };
      case 38:
        return { discriminator: 38, value: A38.readFrom(view) };
      case 39:
        return { discriminator: 39, value: A39.readFrom(view) };
      case 40:
        return { discriminator: 40, value: A40.readFrom(view) };
      case 41:
        return { discriminator: 41, value: A41.readFrom(view) };
      case 42:
        return { discriminator: 42, value: A42.readFrom(view) };
      case 43:
        return { discriminator: 43, value: A43.readFrom(view) };
      case 44:
        return { discriminator: 44, value: A44.readFrom(view) };
      case 45:
        return { discriminator: 45, value: A45.readFrom(view) };
      case 46:
        return { discriminator: 46, value: A46.readFrom(view) };
      case 47:
        return { discriminator: 47, value: A47.readFrom(view) };
      case 48:
        return { discriminator: 48, value: A48.readFrom(view) };
      case 49:
        return { discriminator: 49, value: A49.readFrom(view) };
      case 50:
        return { discriminator: 50, value: A50.readFrom(view) };
      default:
        view.index = end;
        throw new BebopRuntimeError("Unrecognized discriminator while decoding UnionPerfU");
    }
  },
};

export interface IUnionPerfA {
  containerOpcode: number;
  protocolVersion: number;
  u: IUnionPerfU;
}

export const UnionPerfA = {
  encode(message: IUnionPerfA): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IUnionPerfA, view: BebopView): number {
    const before = view.length;
      view.writeUint32(message.containerOpcode);
      view.writeUint32(message.protocolVersion);
      UnionPerfU.encodeInto(message.u, view)
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IUnionPerfA {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IUnionPerfA {
    let field0: number;
    field0 = view.readUint32();
    let field1: number;
    field1 = view.readUint32();
    let field2: IUnionPerfU;
    field2 = UnionPerfU.readFrom(view);
    let message: IUnionPerfA = {
      containerOpcode: field0,
      protocolVersion: field1,
      u: field2,
    };
    return message;
  },
};

/**
 * Option B: an "encodedData" field, that "decode" is called a second time on.
 */
export interface IUnionPerfB {
  protocolVersion: number;
  incomingOpcode: number;
  encodedData: Uint8Array;
}

export const UnionPerfB = {
  encode(message: IUnionPerfB): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IUnionPerfB, view: BebopView): number {
    const before = view.length;
      view.writeUint32(message.protocolVersion);
      view.writeUint32(message.incomingOpcode);
      view.writeBytes(message.encodedData);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IUnionPerfB {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IUnionPerfB {
    let field0: number;
    field0 = view.readUint32();
    let field1: number;
    field1 = view.readUint32();
    let field2: Uint8Array;
    field2 = view.readBytes();
    let message: IUnionPerfB = {
      protocolVersion: field0,
      incomingOpcode: field1,
      encodedData: field2,
    };
    return message;
  },
};

export interface IB1 {
  i1: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B1 = {
  opcode: 0x1,
  encode(message: IB1): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB1, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i1);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB1 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB1 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB1 = {
      i1: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB2 {
  i2: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B2 = {
  opcode: 0x2,
  encode(message: IB2): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB2, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i2);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB2 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB2 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB2 = {
      i2: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB3 {
  i3: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B3 = {
  opcode: 0x3,
  encode(message: IB3): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB3, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i3);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB3 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB3 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB3 = {
      i3: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB4 {
  i4: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B4 = {
  opcode: 0x4,
  encode(message: IB4): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB4, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i4);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB4 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB4 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB4 = {
      i4: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB5 {
  i5: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B5 = {
  opcode: 0x5,
  encode(message: IB5): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB5, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i5);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB5 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB5 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB5 = {
      i5: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB6 {
  i6: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B6 = {
  opcode: 0x6,
  encode(message: IB6): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB6, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i6);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB6 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB6 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB6 = {
      i6: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB7 {
  i7: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B7 = {
  opcode: 0x7,
  encode(message: IB7): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB7, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i7);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB7 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB7 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB7 = {
      i7: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB8 {
  i8: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B8 = {
  opcode: 0x8,
  encode(message: IB8): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB8, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i8);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB8 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB8 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB8 = {
      i8: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB9 {
  i9: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B9 = {
  opcode: 0x9,
  encode(message: IB9): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB9, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i9);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB9 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB9 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB9 = {
      i9: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB10 {
  i10: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B10 = {
  opcode: 0xA,
  encode(message: IB10): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB10, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i10);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB10 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB10 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB10 = {
      i10: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB11 {
  i11: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B11 = {
  opcode: 0xB,
  encode(message: IB11): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB11, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i11);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB11 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB11 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB11 = {
      i11: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB12 {
  i12: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B12 = {
  opcode: 0xC,
  encode(message: IB12): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB12, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i12);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB12 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB12 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB12 = {
      i12: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB13 {
  i13: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B13 = {
  opcode: 0xD,
  encode(message: IB13): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB13, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i13);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB13 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB13 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB13 = {
      i13: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB14 {
  i14: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B14 = {
  opcode: 0xE,
  encode(message: IB14): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB14, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i14);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB14 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB14 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB14 = {
      i14: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB15 {
  i15: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B15 = {
  opcode: 0xF,
  encode(message: IB15): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB15, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i15);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB15 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB15 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB15 = {
      i15: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB16 {
  i16: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B16 = {
  opcode: 0x10,
  encode(message: IB16): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB16, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i16);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB16 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB16 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB16 = {
      i16: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB17 {
  i17: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B17 = {
  opcode: 0x11,
  encode(message: IB17): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB17, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i17);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB17 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB17 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB17 = {
      i17: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB18 {
  i18: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B18 = {
  opcode: 0x12,
  encode(message: IB18): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB18, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i18);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB18 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB18 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB18 = {
      i18: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB19 {
  i19: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B19 = {
  opcode: 0x13,
  encode(message: IB19): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB19, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i19);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB19 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB19 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB19 = {
      i19: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB20 {
  i20: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B20 = {
  opcode: 0x14,
  encode(message: IB20): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB20, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i20);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB20 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB20 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB20 = {
      i20: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB21 {
  i21: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B21 = {
  opcode: 0x15,
  encode(message: IB21): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB21, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i21);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB21 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB21 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB21 = {
      i21: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB22 {
  i22: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B22 = {
  opcode: 0x16,
  encode(message: IB22): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB22, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i22);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB22 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB22 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB22 = {
      i22: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB23 {
  i23: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B23 = {
  opcode: 0x17,
  encode(message: IB23): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB23, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i23);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB23 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB23 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB23 = {
      i23: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB24 {
  i24: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B24 = {
  opcode: 0x18,
  encode(message: IB24): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB24, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i24);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB24 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB24 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB24 = {
      i24: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB25 {
  i25: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B25 = {
  opcode: 0x19,
  encode(message: IB25): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB25, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i25);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB25 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB25 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB25 = {
      i25: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB26 {
  i26: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B26 = {
  opcode: 0x1A,
  encode(message: IB26): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB26, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i26);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB26 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB26 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB26 = {
      i26: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB27 {
  i27: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B27 = {
  opcode: 0x1B,
  encode(message: IB27): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB27, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i27);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB27 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB27 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB27 = {
      i27: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB28 {
  i28: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B28 = {
  opcode: 0x1C,
  encode(message: IB28): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB28, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i28);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB28 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB28 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB28 = {
      i28: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB29 {
  i29: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B29 = {
  opcode: 0x1D,
  encode(message: IB29): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB29, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i29);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB29 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB29 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB29 = {
      i29: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB30 {
  i30: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B30 = {
  opcode: 0x1E,
  encode(message: IB30): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB30, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i30);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB30 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB30 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB30 = {
      i30: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB31 {
  i31: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B31 = {
  opcode: 0x1F,
  encode(message: IB31): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB31, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i31);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB31 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB31 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB31 = {
      i31: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB32 {
  i32: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B32 = {
  opcode: 0x20,
  encode(message: IB32): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB32, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i32);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB32 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB32 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB32 = {
      i32: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB33 {
  i33: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B33 = {
  opcode: 0x21,
  encode(message: IB33): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB33, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i33);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB33 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB33 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB33 = {
      i33: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB34 {
  i34: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B34 = {
  opcode: 0x22,
  encode(message: IB34): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB34, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i34);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB34 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB34 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB34 = {
      i34: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB35 {
  i35: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B35 = {
  opcode: 0x23,
  encode(message: IB35): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB35, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i35);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB35 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB35 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB35 = {
      i35: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB36 {
  i36: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B36 = {
  opcode: 0x24,
  encode(message: IB36): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB36, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i36);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB36 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB36 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB36 = {
      i36: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB37 {
  i37: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B37 = {
  opcode: 0x25,
  encode(message: IB37): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB37, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i37);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB37 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB37 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB37 = {
      i37: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB38 {
  i38: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B38 = {
  opcode: 0x26,
  encode(message: IB38): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB38, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i38);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB38 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB38 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB38 = {
      i38: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB39 {
  i39: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B39 = {
  opcode: 0x27,
  encode(message: IB39): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB39, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i39);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB39 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB39 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB39 = {
      i39: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB40 {
  i40: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B40 = {
  opcode: 0x28,
  encode(message: IB40): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB40, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i40);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB40 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB40 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB40 = {
      i40: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB41 {
  i41: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B41 = {
  opcode: 0x29,
  encode(message: IB41): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB41, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i41);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB41 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB41 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB41 = {
      i41: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB42 {
  i42: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B42 = {
  opcode: 0x2A,
  encode(message: IB42): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB42, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i42);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB42 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB42 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB42 = {
      i42: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB43 {
  i43: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B43 = {
  opcode: 0x2B,
  encode(message: IB43): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB43, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i43);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB43 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB43 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB43 = {
      i43: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB44 {
  i44: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B44 = {
  opcode: 0x2C,
  encode(message: IB44): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB44, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i44);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB44 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB44 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB44 = {
      i44: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB45 {
  i45: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B45 = {
  opcode: 0x2D,
  encode(message: IB45): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB45, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i45);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB45 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB45 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB45 = {
      i45: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB46 {
  i46: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B46 = {
  opcode: 0x2E,
  encode(message: IB46): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB46, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i46);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB46 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB46 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB46 = {
      i46: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB47 {
  i47: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B47 = {
  opcode: 0x2F,
  encode(message: IB47): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB47, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i47);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB47 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB47 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB47 = {
      i47: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB48 {
  i48: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B48 = {
  opcode: 0x30,
  encode(message: IB48): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB48, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i48);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB48 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB48 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB48 = {
      i48: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB49 {
  i49: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B49 = {
  opcode: 0x31,
  encode(message: IB49): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB49, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i49);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB49 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB49 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB49 = {
      i49: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

export interface IB50 {
  i50: number;
  u: bigint;
  f: number;
  s: string;
  g: string;
  b: boolean;
}

export const B50 = {
  opcode: 0x32,
  encode(message: IB50): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IB50, view: BebopView): number {
    const before = view.length;
      view.writeInt32(message.i50);
      view.writeUint64(message.u);
      view.writeFloat64(message.f);
      view.writeString(message.s);
      view.writeGuid(message.g);
      view.writeByte(Number(message.b));
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IB50 {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IB50 {
    let field0: number;
    field0 = view.readInt32();
    let field1: bigint;
    field1 = view.readUint64();
    let field2: number;
    field2 = view.readFloat64();
    let field3: string;
    field3 = view.readString();
    let field4: string;
    field4 = view.readGuid();
    let field5: boolean;
    field5 = !!view.readByte();
    let message: IB50 = {
      i50: field0,
      u: field1,
      f: field2,
      s: field3,
      g: field4,
      b: field5,
    };
    return message;
  },
};

