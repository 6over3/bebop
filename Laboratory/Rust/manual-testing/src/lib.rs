//!
//! This code was generated by a tool.
//!
//!
//!   bebopc version:
//!       0.0.1-20210728-2315
//!
//!
//!   bebopc source:
//!       https://github.com/RainwayApp/bebop
//!
//!
//! Changes to this file may cause incorrect behavior and will be lost if
//! the code is regenerated.
//!

#![allow(warnings)]

use std::io::Write as _;

#[derive(Clone, Debug, PartialEq)]
pub struct BasicTypes<'raw> {
    pub a_bool: bool,
    pub a_byte: u8,
    pub a_int16: i16,
    pub a_uint16: u16,
    pub a_int32: i32,
    pub a_uint32: u32,
    pub a_int64: i64,
    pub a_uint64: u64,
    pub a_float32: f32,
    pub a_float64: f64,
    pub a_string: &'raw str,
    pub a_guid: bebop::Guid,
    pub a_date: bebop::Date,
}

impl<'raw> bebop::SubRecord<'raw> for BasicTypes<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <bool>::MIN_SERIALIZED_SIZE +
        <u8>::MIN_SERIALIZED_SIZE +
        <i16>::MIN_SERIALIZED_SIZE +
        <u16>::MIN_SERIALIZED_SIZE +
        <i32>::MIN_SERIALIZED_SIZE +
        <u32>::MIN_SERIALIZED_SIZE +
        <i64>::MIN_SERIALIZED_SIZE +
        <u64>::MIN_SERIALIZED_SIZE +
        <f32>::MIN_SERIALIZED_SIZE +
        <f64>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE +
        <bebop::Guid>::MIN_SERIALIZED_SIZE +
        <bebop::Date>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.a_bool.serialize(dest)? +
            self.a_byte.serialize(dest)? +
            self.a_int16.serialize(dest)? +
            self.a_uint16.serialize(dest)? +
            self.a_int32.serialize(dest)? +
            self.a_uint32.serialize(dest)? +
            self.a_int64.serialize(dest)? +
            self.a_uint64.serialize(dest)? +
            self.a_float32.serialize(dest)? +
            self.a_float64.serialize(dest)? +
            self.a_string.serialize(dest)? +
            self.a_guid.serialize(dest)? +
            self.a_date.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <bool>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <u8>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <i16>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = <u16>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = <i32>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v5) = <u32>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v6) = <i64>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v7) = <u64>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v8) = <f32>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v9) = <f64>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v10) = <&'raw str>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v11) = <bebop::Guid>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v12) = <bebop::Date>::deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            a_bool: v0,
            a_byte: v1,
            a_int16: v2,
            a_uint16: v3,
            a_int32: v4,
            a_uint32: v5,
            a_int64: v6,
            a_uint64: v7,
            a_float32: v8,
            a_float64: v9,
            a_string: v10,
            a_guid: v11,
            a_date: v12,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for BasicTypes<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct BasicArrays<'raw> {
    pub a_bool: bebop::SliceWrapper<'raw, bool>,
    pub a_byte: bebop::SliceWrapper<'raw, u8>,
    pub a_int16: bebop::SliceWrapper<'raw, i16>,
    pub a_uint16: bebop::SliceWrapper<'raw, u16>,
    pub a_int32: bebop::SliceWrapper<'raw, i32>,
    pub a_uint32: bebop::SliceWrapper<'raw, u32>,
    pub a_int64: bebop::SliceWrapper<'raw, i64>,
    pub a_uint64: bebop::SliceWrapper<'raw, u64>,
    pub a_float32: bebop::SliceWrapper<'raw, f32>,
    pub a_float64: bebop::SliceWrapper<'raw, f64>,
    pub a_string: std::vec::Vec<&'raw str>,
    pub a_guid: bebop::SliceWrapper<'raw, bebop::Guid>,
}

impl<'raw> bebop::SubRecord<'raw> for BasicArrays<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <bebop::SliceWrapper<'raw, bool>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, i16>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, u16>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, i32>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, u32>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, i64>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, u64>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, f32>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, f64>>::MIN_SERIALIZED_SIZE +
        <std::vec::Vec<&'raw str>>::MIN_SERIALIZED_SIZE +
        <bebop::SliceWrapper<'raw, bebop::Guid>>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.a_bool.serialize(dest)? +
            self.a_byte.serialize(dest)? +
            self.a_int16.serialize(dest)? +
            self.a_uint16.serialize(dest)? +
            self.a_int32.serialize(dest)? +
            self.a_uint32.serialize(dest)? +
            self.a_int64.serialize(dest)? +
            self.a_uint64.serialize(dest)? +
            self.a_float32.serialize(dest)? +
            self.a_float64.serialize(dest)? +
            self.a_string.serialize(dest)? +
            self.a_guid.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <bebop::SliceWrapper<'raw, bool>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <bebop::SliceWrapper<'raw, u8>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <bebop::SliceWrapper<'raw, i16>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = <bebop::SliceWrapper<'raw, u16>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = <bebop::SliceWrapper<'raw, i32>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v5) = <bebop::SliceWrapper<'raw, u32>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v6) = <bebop::SliceWrapper<'raw, i64>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v7) = <bebop::SliceWrapper<'raw, u64>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v8) = <bebop::SliceWrapper<'raw, f32>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v9) = <bebop::SliceWrapper<'raw, f64>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v10) = <std::vec::Vec<&'raw str>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v11) = <bebop::SliceWrapper<'raw, bebop::Guid>>::deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            a_bool: v0,
            a_byte: v1,
            a_int16: v2,
            a_uint16: v3,
            a_int32: v4,
            a_uint32: v5,
            a_int64: v6,
            a_uint64: v7,
            a_float32: v8,
            a_float64: v9,
            a_string: v10,
            a_guid: v11,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for BasicArrays<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct S {
    pub x: i32,
    pub y: i32,
}

impl<'raw> bebop::SubRecord<'raw> for S {
    const MIN_SERIALIZED_SIZE: usize =
        <i32>::MIN_SERIALIZED_SIZE +
        <i32>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.x.serialize(dest)? +
            self.y.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <i32>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <i32>::deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            x: v0,
            y: v1,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for S {}

#[derive(Clone, Debug, PartialEq)]
pub struct SomeMaps<'raw> {
    pub m1: std::collections::HashMap<bool, bool>,
    pub m2: std::collections::HashMap<&'raw str, std::collections::HashMap<&'raw str, &'raw str>>,
    pub m3: std::vec::Vec<std::collections::HashMap<i32, std::vec::Vec<std::collections::HashMap<bool, S>>>>,
    pub m4: std::vec::Vec<std::collections::HashMap<&'raw str, bebop::SliceWrapper<'raw, f32>>>,
}

impl<'raw> bebop::SubRecord<'raw> for SomeMaps<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <std::collections::HashMap<bool, bool>>::MIN_SERIALIZED_SIZE +
        <std::collections::HashMap<&'raw str, std::collections::HashMap<&'raw str, &'raw str>>>::MIN_SERIALIZED_SIZE +
        <std::vec::Vec<std::collections::HashMap<i32, std::vec::Vec<std::collections::HashMap<bool, S>>>>>::MIN_SERIALIZED_SIZE +
        <std::vec::Vec<std::collections::HashMap<&'raw str, bebop::SliceWrapper<'raw, f32>>>>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.m1.serialize(dest)? +
            self.m2.serialize(dest)? +
            self.m3.serialize(dest)? +
            self.m4.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <std::collections::HashMap<bool, bool>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <std::collections::HashMap<&'raw str, std::collections::HashMap<&'raw str, &'raw str>>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <std::vec::Vec<std::collections::HashMap<i32, std::vec::Vec<std::collections::HashMap<bool, S>>>>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = <std::vec::Vec<std::collections::HashMap<&'raw str, bebop::SliceWrapper<'raw, f32>>>>::deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            m1: v0,
            m2: v1,
            m3: v2,
            m4: v3,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for SomeMaps<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct TestInt32Array<'raw> {
    pub a: bebop::SliceWrapper<'raw, i32>,
}

impl<'raw> bebop::SubRecord<'raw> for TestInt32Array<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <bebop::SliceWrapper<'raw, i32>>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.a.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <bebop::SliceWrapper<'raw, i32>>::deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            a: v0,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for TestInt32Array<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct ArrayOfStrings<'raw> {
    pub strings: std::vec::Vec<&'raw str>,
}

impl<'raw> bebop::SubRecord<'raw> for ArrayOfStrings<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <std::vec::Vec<&'raw str>>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.strings.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <std::vec::Vec<&'raw str>>::deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            strings: v0,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for ArrayOfStrings<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct StructOfStructs<'raw> {
    pub basic_types: BasicTypes<'raw>,
    pub basic_arrays: BasicArrays<'raw>,
}

impl<'raw> bebop::SubRecord<'raw> for StructOfStructs<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <BasicTypes<'raw>>::MIN_SERIALIZED_SIZE +
        <BasicArrays<'raw>>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.basic_types.serialize(dest)? +
            self.basic_arrays.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <BasicTypes<'raw>>::deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <BasicArrays<'raw>>::deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            basic_types: v0,
            basic_arrays: v1,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for StructOfStructs<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct EmptyStruct {
}

impl<'raw> bebop::SubRecord<'raw> for EmptyStruct {
    const MIN_SERIALIZED_SIZE: usize = 0;
    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(0)
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }


        Ok((i, Self {
        }))
    }
}

impl<'raw> bebop::Record<'raw> for EmptyStruct {}

#[derive(Clone, Debug, PartialEq)]
pub struct OpcodeStruct {
    pub x: i32,
}

impl<'raw> bebop::SubRecord<'raw> for OpcodeStruct {
    const MIN_SERIALIZED_SIZE: usize =
        <i32>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.x.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <i32>::deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            x: v0,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for OpcodeStruct {
    const OPCODE: core::option::Option<u32> = Some(0x444C5257);
}

#[derive(Clone, Debug, PartialEq)]
pub struct ShouldNotHaveLifetime {
    pub v: std::vec::Vec<OpcodeStruct>,
}

impl<'raw> bebop::SubRecord<'raw> for ShouldNotHaveLifetime {
    const MIN_SERIALIZED_SIZE: usize =
        <std::vec::Vec<OpcodeStruct>>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.v.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <std::vec::Vec<OpcodeStruct>>::deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            v: v0,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for ShouldNotHaveLifetime {}

