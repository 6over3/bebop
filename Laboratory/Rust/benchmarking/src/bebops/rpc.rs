//
// This code was generated by a tool.
//
//
//   bebopc version:
//       2.4.2
//
//
//   bebopc source:
//       https://github.com/RainwayApp/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use ::std::io::Write as _;
use ::core::convert::TryInto as _;
use ::bebop::FixedSized as _;
use ::bebop::Record as _;

/// A fixed-sized struct
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct ObjA {
    pub a: i32,
    pub b: i16,
    pub c: ::bebop::Date,
    pub d: ::bebop::Guid,
}

impl ::bebop::FixedSized for ObjA {}

impl<> ::core::convert::From<(i32, i16, ::bebop::Date, ::bebop::Guid)> for ObjA {
    fn from(value: (i32, i16, ::bebop::Date, ::bebop::Guid)) -> Self {
        Self { a: value.0, b: value.1, c: value.2, d: value.3 }
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for ObjA {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.a._serialize_chained(dest)? +
            self.b._serialize_chained(dest)? +
            self.c._serialize_chained(dest)? +
            self.d._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            a: v0,
            b: v1,
            c: v2,
            d: v3,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for ObjA {}

#[derive(Clone, Debug, PartialEq, Default)]
pub struct ObjB<'raw> {
    /// Field 1
    pub a: ::core::option::Option<i32>,
    /// Field 2
    pub b: ::core::option::Option<i16>,
    /// Field 3
    pub c: ::core::option::Option<::bebop::Date>,
    /// Field 4
    pub d: ::core::option::Option<::bebop::Guid>,
    /// Field 5
    pub e: ::core::option::Option<&'raw str>,
}

impl<'raw> ::bebop::SubRecord<'raw> for ObjB<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    #[inline]
    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE + 1 +
        self.a.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0) +
        self.b.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0) +
        self.c.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0) +
        self.d.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0) +
        self.e.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0)
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
        if let Some(ref v) = self.a {
            1u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.b {
            2u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.c {
            3u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.d {
            4u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.e {
            5u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        0u8._serialize_chained(dest)?;
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
        i += ::bebop::LEN_SIZE;

        #[cfg(not(feature = "bebop-unchecked"))]
        if len == 0 {
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len {
            return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
        }

        let mut _a = None;
        let mut _b = None;
        let mut _c = None;
        let mut _d = None;
        let mut _e = None;

        #[cfg(not(feature = "bebop-unchecked"))]
        let mut last = 0;

        while i < len {
            let di = raw[i];

            #[cfg(not(feature = "bebop-unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "bebop-unchecked"))]
                    if _a.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _a = Some(value)
                }
                2 => {
                    #[cfg(not(feature = "bebop-unchecked"))]
                    if _b.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _b = Some(value)
                }
                3 => {
                    #[cfg(not(feature = "bebop-unchecked"))]
                    if _c.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _c = Some(value)
                }
                4 => {
                    #[cfg(not(feature = "bebop-unchecked"))]
                    if _d.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _d = Some(value)
                }
                5 => {
                    #[cfg(not(feature = "bebop-unchecked"))]
                    if _e.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _e = Some(value)
                }
                _ => {
                    i = len;
                    break;
                }
            }
        }

        if i != len {
            debug_assert!(i > len);
            return Err(::bebop::DeserializeError::CorruptFrame)
        }

        Ok((i, Self {
            a: _a,
            b: _b,
            c: _c,
            d: _d,
            e: _e,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for ObjB<'raw> {}

/// A type which contains raw data with some header info
#[derive(Clone, Debug, PartialEq)]
pub struct ObjC<'raw> {
    pub a: ObjA,
    pub b: &'raw str,
    pub c: ::bebop::SliceWrapper<'raw, f32>,
}

impl<'raw> ::core::convert::From<(ObjA, &'raw str, ::bebop::SliceWrapper<'raw, f32>)> for ObjC<'raw> {
    fn from(value: (ObjA, &'raw str, ::bebop::SliceWrapper<'raw, f32>)) -> Self {
        Self { a: value.0, b: value.1, c: value.2 }
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for ObjC<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <ObjA>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE +
        <::bebop::SliceWrapper<'raw, f32>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.a.serialized_size() +
        self.b.serialized_size() +
        self.c.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.a._serialize_chained(dest)? +
            self.b._serialize_chained(dest)? +
            self.c._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            a: v0,
            b: v1,
            c: v2,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for ObjC<'raw> {}

/// Wrapped return type of 'ping' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SPingReturn {
}

impl ::bebop::FixedSized for SPingReturn {}

impl<> ::core::convert::From<()> for SPingReturn {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SPingReturn> for () {
    fn from(value: SPingReturn) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SPingReturn {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SPingReturn {}

/// Wrapped arguments type of 'ping' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SPingArgs {
}

impl ::bebop::FixedSized for SPingArgs {}

impl<> ::core::convert::From<()> for SPingArgs {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SPingArgs> for () {
    fn from(value: SPingArgs) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SPingArgs {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SPingArgs {}

/// hash("{}{}")
pub const _S_PING_SIGNATURE: u32 = 0x6be092d0;

/// Wrapped return type of 'submitA' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SSubmitAReturn {
}

impl ::bebop::FixedSized for SSubmitAReturn {}

impl<> ::core::convert::From<()> for SSubmitAReturn {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SSubmitAReturn> for () {
    fn from(value: SSubmitAReturn) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SSubmitAReturn {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SSubmitAReturn {}

/// Wrapped arguments type of 'submitA' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SSubmitAArgs {
    pub a: ObjA,
}

impl ::bebop::FixedSized for SSubmitAArgs {}

impl<> ::core::convert::From<ObjA> for SSubmitAArgs {
    fn from(value: ObjA) -> Self {
        Self { a: value }
    }
}

impl<> ::core::convert::From<SSubmitAArgs> for ObjA {
    fn from(value: SSubmitAArgs) -> Self {
        value.a
    }
}

impl<> ::core::ops::Deref for SSubmitAArgs {
    type Target = ObjA;

    fn deref(&self) -> &Self::Target {
        &self.a
    }
}

impl<> ::core::ops::DerefMut for SSubmitAArgs {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.a
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SSubmitAArgs {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.a._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            a: v0,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for SSubmitAArgs {}

/// hash("{}{{int32,int16,date,guid}}")
pub const _S_SUBMIT_A_SIGNATURE: u32 = 0x14714c68;

/// Wrapped return type of 'submitB' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SSubmitBReturn {
}

impl ::bebop::FixedSized for SSubmitBReturn {}

impl<> ::core::convert::From<()> for SSubmitBReturn {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SSubmitBReturn> for () {
    fn from(value: SSubmitBReturn) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SSubmitBReturn {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SSubmitBReturn {}

/// Wrapped arguments type of 'submitB' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq)]
pub struct SSubmitBArgs<'raw> {
    pub b: ObjB<'raw>,
}

impl<'raw> ::core::convert::From<ObjB<'raw>> for SSubmitBArgs<'raw> {
    fn from(value: ObjB<'raw>) -> Self {
        Self { b: value }
    }
}

impl<'raw> ::core::convert::From<SSubmitBArgs<'raw>> for ObjB<'raw> {
    fn from(value: SSubmitBArgs<'raw>) -> Self {
        value.b
    }
}

impl<'raw> ::core::ops::Deref for SSubmitBArgs<'raw> {
    type Target = ObjB<'raw>;

    fn deref(&self) -> &Self::Target {
        &self.b
    }
}

impl<'raw> ::core::ops::DerefMut for SSubmitBArgs<'raw> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.b
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SSubmitBArgs<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <ObjB<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.b.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.b._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            b: v0,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for SSubmitBArgs<'raw> {}

/// hash("{}{{1:int32,2:int16,3:date,4:guid,5:string}}")
pub const _S_SUBMIT_B_SIGNATURE: u32 = 0xd910de3b;

/// Wrapped return type of 'submitAB' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SSubmitABReturn {
}

impl ::bebop::FixedSized for SSubmitABReturn {}

impl<> ::core::convert::From<()> for SSubmitABReturn {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SSubmitABReturn> for () {
    fn from(value: SSubmitABReturn) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SSubmitABReturn {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SSubmitABReturn {}

/// Wrapped arguments type of 'submitAB' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq)]
pub struct SSubmitABArgs<'raw> {
    pub a: ObjA,
    pub b: ObjB<'raw>,
    pub c: bool,
    pub d: &'raw str,
}

impl<'raw> ::core::convert::From<(ObjA, ObjB<'raw>, bool, &'raw str)> for SSubmitABArgs<'raw> {
    fn from(value: (ObjA, ObjB<'raw>, bool, &'raw str)) -> Self {
        Self { a: value.0, b: value.1, c: value.2, d: value.3 }
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SSubmitABArgs<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <ObjA>::MIN_SERIALIZED_SIZE +
        <ObjB<'raw>>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.a.serialized_size() +
        self.b.serialized_size() +
        self.c.serialized_size() +
        self.d.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.a._serialize_chained(dest)? +
            self.b._serialize_chained(dest)? +
            self.c._serialize_chained(dest)? +
            self.d._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            a: v0,
            b: v1,
            c: v2,
            d: v3,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for SSubmitABArgs<'raw> {}

/// hash("{}{{int32,int16,date,guid},{1:int32,2:int16,3:date,4:guid,5:string},bool,string}")
pub const _S_SUBMIT_A_B_SIGNATURE: u32 = 0x17097b7b;

/// Wrapped return type of 'submitC' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SSubmitCReturn {
}

impl ::bebop::FixedSized for SSubmitCReturn {}

impl<> ::core::convert::From<()> for SSubmitCReturn {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SSubmitCReturn> for () {
    fn from(value: SSubmitCReturn) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SSubmitCReturn {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SSubmitCReturn {}

/// Wrapped arguments type of 'submitC' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq)]
pub struct SSubmitCArgs<'raw> {
    pub a: i32,
    pub b: ObjC<'raw>,
}

impl<'raw> ::core::convert::From<(i32, ObjC<'raw>)> for SSubmitCArgs<'raw> {
    fn from(value: (i32, ObjC<'raw>)) -> Self {
        Self { a: value.0, b: value.1 }
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SSubmitCArgs<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <i32>::MIN_SERIALIZED_SIZE +
        <ObjC<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.a.serialized_size() +
        self.b.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.a._serialize_chained(dest)? +
            self.b._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            a: v0,
            b: v1,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for SSubmitCArgs<'raw> {}

/// hash("{}{int32,{{int32,int16,date,guid},string,[float32]}}")
pub const _S_SUBMIT_C_SIGNATURE: u32 = 0xa774abdb;

/// Wrapped return type of 'respondA' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SRespondAReturn {
    pub value: ObjA,
}

impl ::bebop::FixedSized for SRespondAReturn {}

impl<> ::core::convert::From<ObjA> for SRespondAReturn {
    fn from(value: ObjA) -> Self {
        Self { value: value }
    }
}

impl<> ::core::convert::From<SRespondAReturn> for ObjA {
    fn from(value: SRespondAReturn) -> Self {
        value.value
    }
}

impl<> ::core::ops::Deref for SRespondAReturn {
    type Target = ObjA;

    fn deref(&self) -> &Self::Target {
        &self.value
    }
}

impl<> ::core::ops::DerefMut for SRespondAReturn {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.value
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SRespondAReturn {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.value._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            value: v0,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for SRespondAReturn {}

/// Wrapped arguments type of 'respondA' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SRespondAArgs {
}

impl ::bebop::FixedSized for SRespondAArgs {}

impl<> ::core::convert::From<()> for SRespondAArgs {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SRespondAArgs> for () {
    fn from(value: SRespondAArgs) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SRespondAArgs {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SRespondAArgs {}

/// hash("{{int32,int16,date,guid}}{}")
pub const _S_RESPOND_A_SIGNATURE: u32 = 0x1146a2c5;

/// Wrapped return type of 'respondB' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq)]
pub struct SRespondBReturn<'raw> {
    pub value: ObjB<'raw>,
}

impl<'raw> ::core::convert::From<ObjB<'raw>> for SRespondBReturn<'raw> {
    fn from(value: ObjB<'raw>) -> Self {
        Self { value: value }
    }
}

impl<'raw> ::core::convert::From<SRespondBReturn<'raw>> for ObjB<'raw> {
    fn from(value: SRespondBReturn<'raw>) -> Self {
        value.value
    }
}

impl<'raw> ::core::ops::Deref for SRespondBReturn<'raw> {
    type Target = ObjB<'raw>;

    fn deref(&self) -> &Self::Target {
        &self.value
    }
}

impl<'raw> ::core::ops::DerefMut for SRespondBReturn<'raw> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.value
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SRespondBReturn<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <ObjB<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.value.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.value._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            value: v0,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for SRespondBReturn<'raw> {}

/// Wrapped arguments type of 'respondB' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SRespondBArgs {
}

impl ::bebop::FixedSized for SRespondBArgs {}

impl<> ::core::convert::From<()> for SRespondBArgs {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SRespondBArgs> for () {
    fn from(value: SRespondBArgs) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SRespondBArgs {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SRespondBArgs {}

/// hash("{{1:int32,2:int16,3:date,4:guid,5:string}}{}")
pub const _S_RESPOND_B_SIGNATURE: u32 = 0x8a8d5853;

/// Wrapped return type of 'respondC' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq)]
pub struct SRespondCReturn<'raw> {
    pub value: ObjC<'raw>,
}

impl<'raw> ::core::convert::From<ObjC<'raw>> for SRespondCReturn<'raw> {
    fn from(value: ObjC<'raw>) -> Self {
        Self { value: value }
    }
}

impl<'raw> ::core::convert::From<SRespondCReturn<'raw>> for ObjC<'raw> {
    fn from(value: SRespondCReturn<'raw>) -> Self {
        value.value
    }
}

impl<'raw> ::core::ops::Deref for SRespondCReturn<'raw> {
    type Target = ObjC<'raw>;

    fn deref(&self) -> &Self::Target {
        &self.value
    }
}

impl<'raw> ::core::ops::DerefMut for SRespondCReturn<'raw> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.value
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SRespondCReturn<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <ObjC<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.value.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.value._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            value: v0,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for SRespondCReturn<'raw> {}

/// Wrapped arguments type of 'respondC' in rpc service 'S'.
#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SRespondCArgs {
}

impl ::bebop::FixedSized for SRespondCArgs {}

impl<> ::core::convert::From<()> for SRespondCArgs {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SRespondCArgs> for () {
    fn from(value: SRespondCArgs) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SRespondCArgs {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SRespondCArgs {}

/// hash("{{{int32,int16,date,guid},string,[float32]}}{}")
pub const _S_RESPOND_C_SIGNATURE: u32 = 0x0c4d9793;

#[derive(Clone, Debug, PartialEq)]
pub struct SServiceNameReturn<'raw> {
    pub value: &'raw str,
}

impl<'raw> ::core::convert::From<&'raw str> for SServiceNameReturn<'raw> {
    fn from(value: &'raw str) -> Self {
        Self { value: value }
    }
}

impl<'raw> ::core::convert::From<SServiceNameReturn<'raw>> for &'raw str {
    fn from(value: SServiceNameReturn<'raw>) -> Self {
        value.value
    }
}

impl<'raw> ::core::ops::Deref for SServiceNameReturn<'raw> {
    type Target = &'raw str;

    fn deref(&self) -> &Self::Target {
        &self.value
    }
}

impl<'raw> ::core::ops::DerefMut for SServiceNameReturn<'raw> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.value
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SServiceNameReturn<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <&'raw str>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.value.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.value._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            value: v0,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for SServiceNameReturn<'raw> {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct SServiceNameArgs {
}

impl ::bebop::FixedSized for SServiceNameArgs {}

impl<> ::core::convert::From<()> for SServiceNameArgs {
    fn from(value: ()) -> Self {
        Self {}
    }
}

impl<> ::core::convert::From<SServiceNameArgs> for () {
    fn from(value: SServiceNameArgs) -> Self {
        ()
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for SServiceNameArgs {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(0)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        Ok((0, Self {}))
    }
}

impl<'raw> ::bebop::Record<'raw> for SServiceNameArgs {}

/// hash("{string}{}")
pub const _S_SERVICE_NAME_SIGNATURE: u32 = 0x543bbba2;

#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use ::std::io::Write as _;
    use ::core::convert::TryInto as _;
    use ::bebop::FixedSized as _;
    use ::bebop::Record as _;

    pub use super::ObjA;

    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct ObjB {
        /// Field 1
        pub a: ::core::option::Option<i32>,
        /// Field 2
        pub b: ::core::option::Option<i16>,
        /// Field 3
        pub c: ::core::option::Option<::bebop::Date>,
        /// Field 4
        pub d: ::core::option::Option<::bebop::Guid>,
        /// Field 5
        pub e: ::core::option::Option<::std::string::String>,
    }

    impl<'raw> ::core::convert::From<super::ObjB<'raw>> for ObjB {
        fn from(value: super::ObjB) -> Self {
            Self {
                a: value.a,
                b: value.b,
                c: value.c,
                d: value.d,
                e: value.e.map(|value| value.into()),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for ObjB {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        #[inline]
        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE + 1 +
            self.a.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0) +
            self.b.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0) +
            self.c.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0) +
            self.d.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0) +
            self.e.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0)
        }

        fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
            if let Some(ref v) = self.a {
                1u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.b {
                2u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.c {
                3u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.d {
                4u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.e {
                5u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            0u8._serialize_chained(dest)?;
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
            i += ::bebop::LEN_SIZE;

            #[cfg(not(feature = "bebop-unchecked"))]
            if len == 0 {
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            if raw.len() < len {
                return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
            }

            let mut _a = None;
            let mut _b = None;
            let mut _c = None;
            let mut _d = None;
            let mut _e = None;

            #[cfg(not(feature = "bebop-unchecked"))]
            let mut last = 0;

            while i < len {
                let di = raw[i];

                #[cfg(not(feature = "bebop-unchecked"))]
                if di != 0 {
                    if di < last {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }
                    last = di;
                }

                i += 1;
                match di {
                    0 => {
                        break;
                    }
                    1 => {
                        #[cfg(not(feature = "bebop-unchecked"))]
                        if _a.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _a = Some(value)
                    }
                    2 => {
                        #[cfg(not(feature = "bebop-unchecked"))]
                        if _b.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _b = Some(value)
                    }
                    3 => {
                        #[cfg(not(feature = "bebop-unchecked"))]
                        if _c.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _c = Some(value)
                    }
                    4 => {
                        #[cfg(not(feature = "bebop-unchecked"))]
                        if _d.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _d = Some(value)
                    }
                    5 => {
                        #[cfg(not(feature = "bebop-unchecked"))]
                        if _e.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _e = Some(value)
                    }
                    _ => {
                        i = len;
                        break;
                    }
                }
            }

            if i != len {
                debug_assert!(i > len);
                return Err(::bebop::DeserializeError::CorruptFrame)
            }

            Ok((i, Self {
                a: _a,
                b: _b,
                c: _c,
                d: _d,
                e: _e,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for ObjB {}

    /// A type which contains raw data with some header info
    #[derive(Clone, Debug, PartialEq)]
    pub struct ObjC {
        pub a: ObjA,
        pub b: ::std::string::String,
        pub c: ::std::vec::Vec<f32>,
    }

    impl<'raw> ::core::convert::From<super::ObjC<'raw>> for ObjC {
        fn from(value: super::ObjC) -> Self {
            Self {
                a: value.a,
                b: value.b.into(),
                c: value.c.iter().map(|value| value).collect(),
            }
        }
    }

    impl<> ::core::convert::From<(ObjA, ::std::string::String, ::std::vec::Vec<f32>)> for ObjC {
        fn from(value: (ObjA, ::std::string::String, ::std::vec::Vec<f32>)) -> Self {
            Self { a: value.0, b: value.1, c: value.2 }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for ObjC {
        const MIN_SERIALIZED_SIZE: usize =
            <ObjA>::MIN_SERIALIZED_SIZE +
            <::std::string::String>::MIN_SERIALIZED_SIZE +
            <::std::vec::Vec<f32>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.a.serialized_size() +
            self.b.serialized_size() +
            self.c.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.a._serialize_chained(dest)? +
                self.b._serialize_chained(dest)? +
                self.c._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                a: v0,
                b: v1,
                c: v2,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for ObjC {}

    pub use super::SPingReturn;

    pub use super::SPingArgs;

    pub use super::_S_PING_SIGNATURE;

    pub use super::SSubmitAReturn;

    pub use super::SSubmitAArgs;

    pub use super::_S_SUBMIT_A_SIGNATURE;

    pub use super::SSubmitBReturn;

    /// Wrapped arguments type of 'submitB' in rpc service 'S'.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SSubmitBArgs {
        pub b: ObjB,
    }

    impl<'raw> ::core::convert::From<super::SSubmitBArgs<'raw>> for SSubmitBArgs {
        fn from(value: super::SSubmitBArgs) -> Self {
            Self {
                b: value.b.into(),
            }
        }
    }

    impl<> ::core::convert::From<ObjB> for SSubmitBArgs {
        fn from(value: ObjB) -> Self {
            Self { b: value }
        }
    }

    impl<> ::core::convert::From<SSubmitBArgs> for ObjB {
        fn from(value: SSubmitBArgs) -> Self {
            value.b
        }
    }

    impl<> ::core::ops::Deref for SSubmitBArgs {
        type Target = ObjB;

        fn deref(&self) -> &Self::Target {
            &self.b
        }
    }

    impl<> ::core::ops::DerefMut for SSubmitBArgs {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.b
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for SSubmitBArgs {
        const MIN_SERIALIZED_SIZE: usize =
            <ObjB>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.b.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.b._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                b: v0,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for SSubmitBArgs {}

    pub use super::_S_SUBMIT_B_SIGNATURE;

    pub use super::SSubmitABReturn;

    /// Wrapped arguments type of 'submitAB' in rpc service 'S'.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SSubmitABArgs {
        pub a: ObjA,
        pub b: ObjB,
        pub c: bool,
        pub d: ::std::string::String,
    }

    impl<'raw> ::core::convert::From<super::SSubmitABArgs<'raw>> for SSubmitABArgs {
        fn from(value: super::SSubmitABArgs) -> Self {
            Self {
                a: value.a,
                b: value.b.into(),
                c: value.c,
                d: value.d.into(),
            }
        }
    }

    impl<> ::core::convert::From<(ObjA, ObjB, bool, ::std::string::String)> for SSubmitABArgs {
        fn from(value: (ObjA, ObjB, bool, ::std::string::String)) -> Self {
            Self { a: value.0, b: value.1, c: value.2, d: value.3 }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for SSubmitABArgs {
        const MIN_SERIALIZED_SIZE: usize =
            <ObjA>::MIN_SERIALIZED_SIZE +
            <ObjB>::MIN_SERIALIZED_SIZE +
            <bool>::MIN_SERIALIZED_SIZE +
            <::std::string::String>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.a.serialized_size() +
            self.b.serialized_size() +
            self.c.serialized_size() +
            self.d.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.a._serialize_chained(dest)? +
                self.b._serialize_chained(dest)? +
                self.c._serialize_chained(dest)? +
                self.d._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                a: v0,
                b: v1,
                c: v2,
                d: v3,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for SSubmitABArgs {}

    pub use super::_S_SUBMIT_A_B_SIGNATURE;

    pub use super::SSubmitCReturn;

    /// Wrapped arguments type of 'submitC' in rpc service 'S'.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SSubmitCArgs {
        pub a: i32,
        pub b: ObjC,
    }

    impl<'raw> ::core::convert::From<super::SSubmitCArgs<'raw>> for SSubmitCArgs {
        fn from(value: super::SSubmitCArgs) -> Self {
            Self {
                a: value.a,
                b: value.b.into(),
            }
        }
    }

    impl<> ::core::convert::From<(i32, ObjC)> for SSubmitCArgs {
        fn from(value: (i32, ObjC)) -> Self {
            Self { a: value.0, b: value.1 }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for SSubmitCArgs {
        const MIN_SERIALIZED_SIZE: usize =
            <i32>::MIN_SERIALIZED_SIZE +
            <ObjC>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.a.serialized_size() +
            self.b.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.a._serialize_chained(dest)? +
                self.b._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                a: v0,
                b: v1,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for SSubmitCArgs {}

    pub use super::_S_SUBMIT_C_SIGNATURE;

    pub use super::SRespondAReturn;

    pub use super::SRespondAArgs;

    pub use super::_S_RESPOND_A_SIGNATURE;

    /// Wrapped return type of 'respondB' in rpc service 'S'.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SRespondBReturn {
        pub value: ObjB,
    }

    impl<'raw> ::core::convert::From<super::SRespondBReturn<'raw>> for SRespondBReturn {
        fn from(value: super::SRespondBReturn) -> Self {
            Self {
                value: value.value.into(),
            }
        }
    }

    impl<> ::core::convert::From<ObjB> for SRespondBReturn {
        fn from(value: ObjB) -> Self {
            Self { value: value }
        }
    }

    impl<> ::core::convert::From<SRespondBReturn> for ObjB {
        fn from(value: SRespondBReturn) -> Self {
            value.value
        }
    }

    impl<> ::core::ops::Deref for SRespondBReturn {
        type Target = ObjB;

        fn deref(&self) -> &Self::Target {
            &self.value
        }
    }

    impl<> ::core::ops::DerefMut for SRespondBReturn {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.value
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for SRespondBReturn {
        const MIN_SERIALIZED_SIZE: usize =
            <ObjB>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.value.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.value._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                value: v0,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for SRespondBReturn {}

    pub use super::SRespondBArgs;

    pub use super::_S_RESPOND_B_SIGNATURE;

    /// Wrapped return type of 'respondC' in rpc service 'S'.
    #[derive(Clone, Debug, PartialEq)]
    pub struct SRespondCReturn {
        pub value: ObjC,
    }

    impl<'raw> ::core::convert::From<super::SRespondCReturn<'raw>> for SRespondCReturn {
        fn from(value: super::SRespondCReturn) -> Self {
            Self {
                value: value.value.into(),
            }
        }
    }

    impl<> ::core::convert::From<ObjC> for SRespondCReturn {
        fn from(value: ObjC) -> Self {
            Self { value: value }
        }
    }

    impl<> ::core::convert::From<SRespondCReturn> for ObjC {
        fn from(value: SRespondCReturn) -> Self {
            value.value
        }
    }

    impl<> ::core::ops::Deref for SRespondCReturn {
        type Target = ObjC;

        fn deref(&self) -> &Self::Target {
            &self.value
        }
    }

    impl<> ::core::ops::DerefMut for SRespondCReturn {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.value
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for SRespondCReturn {
        const MIN_SERIALIZED_SIZE: usize =
            <ObjC>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.value.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.value._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                value: v0,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for SRespondCReturn {}

    pub use super::SRespondCArgs;

    pub use super::_S_RESPOND_C_SIGNATURE;

    #[derive(Clone, Debug, PartialEq)]
    pub struct SServiceNameReturn {
        pub value: ::std::string::String,
    }

    impl<'raw> ::core::convert::From<super::SServiceNameReturn<'raw>> for SServiceNameReturn {
        fn from(value: super::SServiceNameReturn) -> Self {
            Self {
                value: value.value.into(),
            }
        }
    }

    impl<> ::core::convert::From<::std::string::String> for SServiceNameReturn {
        fn from(value: ::std::string::String) -> Self {
            Self { value: value }
        }
    }

    impl<> ::core::convert::From<SServiceNameReturn> for ::std::string::String {
        fn from(value: SServiceNameReturn) -> Self {
            value.value
        }
    }

    impl<> ::core::ops::Deref for SServiceNameReturn {
        type Target = ::std::string::String;

        fn deref(&self) -> &Self::Target {
            &self.value
        }
    }

    impl<> ::core::ops::DerefMut for SServiceNameReturn {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.value
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for SServiceNameReturn {
        const MIN_SERIALIZED_SIZE: usize =
            <::std::string::String>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.value.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write + ?::core::marker::Sized>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.value._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                value: v0,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for SServiceNameReturn {}

    pub use super::SServiceNameArgs;

    pub use super::_S_SERVICE_NAME_SIGNATURE;

    #[cfg(feature = "S-handlers")]
    pub trait SHandlersDef: ::core::marker::Send + ::core::marker::Sync {
        fn service_name<'f>(&self, handle: ::bebop::rpc::TypedRequestHandle<'f, super::SServiceNameReturn<'f>>) -> ::bebop::rpc::DynFuture<'f, ()> {
            use ::bebop::rpc::CallDetails as _;
            let call_id = handle.call_id().get();
            ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_ok_response(&super::SServiceNameReturn { value: "S" }), "S", "service_name", call_id); }
        }
        fn ping<'f>(&self, _handle: ::bebop::rpc::TypedRequestHandle<'f, super::SPingReturn>) -> ::bebop::rpc::DynFuture<'f, ()>;

        fn submit_a<'f>(&self, _handle: ::bebop::rpc::TypedRequestHandle<'f, super::SSubmitAReturn>, a: ObjA) -> ::bebop::rpc::DynFuture<'f, ()>;

        fn submit_b<'f>(&self, _handle: ::bebop::rpc::TypedRequestHandle<'f, super::SSubmitBReturn>, b: ObjB) -> ::bebop::rpc::DynFuture<'f, ()>;

        fn submit_a_b<'f>(&self, _handle: ::bebop::rpc::TypedRequestHandle<'f, super::SSubmitABReturn>, a: ObjA, b: ObjB, c: bool, d: ::std::string::String) -> ::bebop::rpc::DynFuture<'f, ()>;

        fn submit_c<'f>(&self, _handle: ::bebop::rpc::TypedRequestHandle<'f, super::SSubmitCReturn>, a: i32, b: ObjC) -> ::bebop::rpc::DynFuture<'f, ()>;

        fn respond_a<'f>(&self, _handle: ::bebop::rpc::TypedRequestHandle<'f, super::SRespondAReturn>) -> ::bebop::rpc::DynFuture<'f, ()>;

        fn respond_b<'f>(&self, _handle: ::bebop::rpc::TypedRequestHandle<'f, super::SRespondBReturn<'f>>) -> ::bebop::rpc::DynFuture<'f, ()>;

        fn respond_c<'f>(&self, _handle: ::bebop::rpc::TypedRequestHandle<'f, super::SRespondCReturn<'f>>) -> ::bebop::rpc::DynFuture<'f, ()>;

    }

    #[cfg(feature = "S-handlers")]
    #[repr(transparent)]
    pub struct SHandlers<_Def: SHandlersDef>(_Def);

    #[cfg(feature = "S-handlers")]
    impl<_Def: SHandlersDef> ::core::convert::From<_Def> for SHandlers<_Def> {
        fn from(def: _Def) -> Self { Self(def) }
    }

    #[cfg(feature = "S-handlers")]
    impl<_Def: SHandlersDef> ::core::ops::Deref for SHandlers<_Def> {
        type Target = _Def;

        fn deref(&self) -> &Self::Target { &self.0 }
    }

    #[cfg(feature = "S-handlers")]
    impl<_Def: SHandlersDef> ::bebop::rpc::ServiceHandlers for SHandlers<_Def> {
        fn _name(&self) -> &'static str { "S" }

        fn _recv_call<'f>(&self, datagram: &::bebop::rpc::Datagram, handle: ::bebop::rpc::RequestHandle) -> ::bebop::rpc::DynFuture<'f, ()> {
            use ::bebop::rpc::CallDetails as _;
            if let ::bebop::rpc::Datagram::RpcRequestDatagram { header: req_header, opcode, data } = datagram {
                let call_id = req_header.id;
                let opcode = *opcode;
                match opcode {
                    0 => {
                        if req_header.signature != _S_SERVICE_NAME_SIGNATURE {
                            return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_invalid_sig_response(_S_SERVICE_NAME_SIGNATURE), "S", "service_name", call_id); }
                        }
                        self.service_name(handle.into())
                    }
                    4096 => {
                        if req_header.signature != _S_PING_SIGNATURE {
                            return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_invalid_sig_response(_S_PING_SIGNATURE), "S", "ping", call_id); }
                        }
                        self.ping(handle.into())
                    }
                    8192 => {
                        if req_header.signature != _S_SUBMIT_A_SIGNATURE {
                            return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_invalid_sig_response(_S_SUBMIT_A_SIGNATURE), "S", "submit_a", call_id); }
                        }
                        let args = match SSubmitAArgs::deserialize(data) {
                            Ok(args) => args,
                            Err(err) => return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_decode_error_response(Some(&err.to_string())), "S", "submit_a", call_id) }
                        };
                        self.submit_a(handle.into(), args.a)
                    }
                    8193 => {
                        if req_header.signature != _S_SUBMIT_B_SIGNATURE {
                            return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_invalid_sig_response(_S_SUBMIT_B_SIGNATURE), "S", "submit_b", call_id); }
                        }
                        let args = match SSubmitBArgs::deserialize(data) {
                            Ok(args) => args,
                            Err(err) => return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_decode_error_response(Some(&err.to_string())), "S", "submit_b", call_id) }
                        };
                        self.submit_b(handle.into(), args.b)
                    }
                    8194 => {
                        if req_header.signature != _S_SUBMIT_A_B_SIGNATURE {
                            return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_invalid_sig_response(_S_SUBMIT_A_B_SIGNATURE), "S", "submit_a_b", call_id); }
                        }
                        let args = match SSubmitABArgs::deserialize(data) {
                            Ok(args) => args,
                            Err(err) => return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_decode_error_response(Some(&err.to_string())), "S", "submit_a_b", call_id) }
                        };
                        self.submit_a_b(handle.into(), args.a, args.b, args.c, args.d)
                    }
                    8195 => {
                        if req_header.signature != _S_SUBMIT_C_SIGNATURE {
                            return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_invalid_sig_response(_S_SUBMIT_C_SIGNATURE), "S", "submit_c", call_id); }
                        }
                        let args = match SSubmitCArgs::deserialize(data) {
                            Ok(args) => args,
                            Err(err) => return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_decode_error_response(Some(&err.to_string())), "S", "submit_c", call_id) }
                        };
                        self.submit_c(handle.into(), args.a, args.b)
                    }
                    12289 => {
                        if req_header.signature != _S_RESPOND_A_SIGNATURE {
                            return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_invalid_sig_response(_S_RESPOND_A_SIGNATURE), "S", "respond_a", call_id); }
                        }
                        self.respond_a(handle.into())
                    }
                    12290 => {
                        if req_header.signature != _S_RESPOND_B_SIGNATURE {
                            return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_invalid_sig_response(_S_RESPOND_B_SIGNATURE), "S", "respond_b", call_id); }
                        }
                        self.respond_b(handle.into())
                    }
                    16387 => {
                        if req_header.signature != _S_RESPOND_C_SIGNATURE {
                            return ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_invalid_sig_response(_S_RESPOND_C_SIGNATURE), "S", "respond_c", call_id); }
                        }
                        self.respond_c(handle.into())
                    }
                    _ => ::bebop::dyn_fut! { ::bebop::handle_respond_error!(handle.send_unknown_call_response(), "S", "UNKNOWN", call_id); },
                }
            } else { unreachable!("`_recv_call` Should only ever be provided with Requests.") }
        }
    }

    #[cfg(feature = "S-requests")]
    #[derive(Clone)]
    pub struct SRequests(::std::sync::Weak<::bebop::rpc::RouterContext>);

    #[cfg(feature = "S-requests")]
    impl SRequests {
        #[inline]
        pub async fn service_name(&self, timeout: ::core::option::Option<::core::time::Duration>) -> ::bebop::rpc::RemoteRpcResponse<::std::string::String> {
            self.service_name_raw(timeout, &super::SServiceNameArgs {  })?
            .await.map(|v| v.value)
        }

        pub fn service_name_raw<'data>(&self, timeout: ::core::option::Option<::core::time::Duration>, payload: &'data super::SServiceNameArgs) -> ::bebop::rpc::TransportResult<impl 'data + ::core::marker::Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<SServiceNameReturn>>> {
            let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;
            let fut = zelf.request::<_, SServiceNameReturn> (
                0,
                timeout,
                _S_SERVICE_NAME_SIGNATURE,
                payload,
            );
            Ok(async move { fut.await.map(::core::convert::Into::into) })
        }

        #[inline]
        pub async fn ping(&self, timeout: ::core::option::Option<::core::time::Duration>) -> ::bebop::rpc::RemoteRpcResponse<()> {
            self.ping_raw(timeout, &super::SPingArgs {  })?
            .await?; Ok(())
        }

        pub fn ping_raw<'data>(&self, timeout: ::core::option::Option<::core::time::Duration>, payload: &'data super::SPingArgs) -> ::bebop::rpc::TransportResult<impl 'data + ::core::marker::Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<SPingReturn>>> {
            let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;
            let fut = zelf.request::<_, SPingReturn> (
                4096,
                timeout,
                _S_PING_SIGNATURE,
                payload,
            );
            Ok(fut)
        }

        #[inline]
        pub async fn submit_a(&self, timeout: ::core::option::Option<::core::time::Duration>, a: super::ObjA) -> ::bebop::rpc::RemoteRpcResponse<()> {
            self.submit_a_raw(timeout, &super::SSubmitAArgs { a })?
            .await?; Ok(())
        }

        pub fn submit_a_raw<'data>(&self, timeout: ::core::option::Option<::core::time::Duration>, payload: &'data super::SSubmitAArgs) -> ::bebop::rpc::TransportResult<impl 'data + ::core::marker::Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<SSubmitAReturn>>> {
            let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;
            let fut = zelf.request::<_, SSubmitAReturn> (
                8192,
                timeout,
                _S_SUBMIT_A_SIGNATURE,
                payload,
            );
            Ok(fut)
        }

        #[inline]
        pub async fn submit_b(&self, timeout: ::core::option::Option<::core::time::Duration>, b: super::ObjB<'_>) -> ::bebop::rpc::RemoteRpcResponse<()> {
            self.submit_b_raw(timeout, &super::SSubmitBArgs { b })?
            .await?; Ok(())
        }

        pub fn submit_b_raw<'data>(&self, timeout: ::core::option::Option<::core::time::Duration>, payload: &'data super::SSubmitBArgs) -> ::bebop::rpc::TransportResult<impl 'data + ::core::marker::Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<SSubmitBReturn>>> {
            let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;
            let fut = zelf.request::<_, SSubmitBReturn> (
                8193,
                timeout,
                _S_SUBMIT_B_SIGNATURE,
                payload,
            );
            Ok(fut)
        }

        #[inline]
        pub async fn submit_a_b(&self, timeout: ::core::option::Option<::core::time::Duration>, a: super::ObjA, b: super::ObjB<'_>, c: bool, d: &'_ str) -> ::bebop::rpc::RemoteRpcResponse<()> {
            self.submit_a_b_raw(timeout, &super::SSubmitABArgs { a, b, c, d })?
            .await?; Ok(())
        }

        pub fn submit_a_b_raw<'data>(&self, timeout: ::core::option::Option<::core::time::Duration>, payload: &'data super::SSubmitABArgs) -> ::bebop::rpc::TransportResult<impl 'data + ::core::marker::Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<SSubmitABReturn>>> {
            let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;
            let fut = zelf.request::<_, SSubmitABReturn> (
                8194,
                timeout,
                _S_SUBMIT_A_B_SIGNATURE,
                payload,
            );
            Ok(fut)
        }

        #[inline]
        pub async fn submit_c(&self, timeout: ::core::option::Option<::core::time::Duration>, a: i32, b: super::ObjC<'_>) -> ::bebop::rpc::RemoteRpcResponse<()> {
            self.submit_c_raw(timeout, &super::SSubmitCArgs { a, b })?
            .await?; Ok(())
        }

        pub fn submit_c_raw<'data>(&self, timeout: ::core::option::Option<::core::time::Duration>, payload: &'data super::SSubmitCArgs) -> ::bebop::rpc::TransportResult<impl 'data + ::core::marker::Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<SSubmitCReturn>>> {
            let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;
            let fut = zelf.request::<_, SSubmitCReturn> (
                8195,
                timeout,
                _S_SUBMIT_C_SIGNATURE,
                payload,
            );
            Ok(fut)
        }

        #[inline]
        pub async fn respond_a(&self, timeout: ::core::option::Option<::core::time::Duration>) -> ::bebop::rpc::RemoteRpcResponse<ObjA> {
            self.respond_a_raw(timeout, &super::SRespondAArgs {  })?
            .await.map(|v| v.value)
        }

        pub fn respond_a_raw<'data>(&self, timeout: ::core::option::Option<::core::time::Duration>, payload: &'data super::SRespondAArgs) -> ::bebop::rpc::TransportResult<impl 'data + ::core::marker::Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<SRespondAReturn>>> {
            let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;
            let fut = zelf.request::<_, SRespondAReturn> (
                12289,
                timeout,
                _S_RESPOND_A_SIGNATURE,
                payload,
            );
            Ok(async move { fut.await.map(::core::convert::Into::into) })
        }

        #[inline]
        pub async fn respond_b(&self, timeout: ::core::option::Option<::core::time::Duration>) -> ::bebop::rpc::RemoteRpcResponse<ObjB> {
            self.respond_b_raw(timeout, &super::SRespondBArgs {  })?
            .await.map(|v| v.value)
        }

        pub fn respond_b_raw<'data>(&self, timeout: ::core::option::Option<::core::time::Duration>, payload: &'data super::SRespondBArgs) -> ::bebop::rpc::TransportResult<impl 'data + ::core::marker::Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<SRespondBReturn>>> {
            let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;
            let fut = zelf.request::<_, SRespondBReturn> (
                12290,
                timeout,
                _S_RESPOND_B_SIGNATURE,
                payload,
            );
            Ok(async move { fut.await.map(::core::convert::Into::into) })
        }

        #[inline]
        pub async fn respond_c(&self, timeout: ::core::option::Option<::core::time::Duration>) -> ::bebop::rpc::RemoteRpcResponse<ObjC> {
            self.respond_c_raw(timeout, &super::SRespondCArgs {  })?
            .await.map(|v| v.value)
        }

        pub fn respond_c_raw<'data>(&self, timeout: ::core::option::Option<::core::time::Duration>, payload: &'data super::SRespondCArgs) -> ::bebop::rpc::TransportResult<impl 'data + ::core::marker::Sized + ::core::future::Future<Output = ::bebop::rpc::RemoteRpcResponse<SRespondCReturn>>> {
            let zelf = self.0.upgrade().ok_or(::bebop::rpc::TransportError::NotConnected)?;
            let fut = zelf.request::<_, SRespondCReturn> (
                16387,
                timeout,
                _S_RESPOND_C_SIGNATURE,
                payload,
            );
            Ok(async move { fut.await.map(::core::convert::Into::into) })
        }

    }

    #[cfg(feature = "S-requests")]
    impl ::bebop::rpc::ServiceRequests for SRequests {
        const NAME: &'static str = "S";

        fn new(ctx: ::std::sync::Weak<::bebop::rpc::RouterContext>) -> Self {
            Self(ctx)
        }
    }}
