//!
//! This code was generated by a tool.
//!
//!
//!   bebopc version:
//!       0.0.1-20210727-1832
//!
//!
//!   bebopc source:
//!       https://github.com/RainwayApp/bebop
//!
//!
//! Changes to this file may cause incorrect behavior and will be lost if
//! the code is regenerated.
//!

use bebop::{Record as _, SubRecord as _};

#[derive(Clone, Debug, PartialEq, Default)]
pub struct A {
    /// Field 1
    pub b: core::option::Option<u32>,
}

impl<'raw> bebop::SubRecord<'raw> for A {
    const MIN_SERIALIZED_SIZE: usize = bebop::LEN_SIZE + 1;
    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        let mut buf = Vec::new();
        if let Some(ref v) = self.b {
            buf.push(1);
            v.serialize(&mut buf)?;
        }
        buf.push(0);
        bebop::write_len(dest, buf.len())?;
        dest.write_all(&buf)?;
        Ok(buf.len() + bebop::LEN_SIZE)
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let len = bebop::read_len(raw)?;
        #[cfg(not(feature = "unchecked"))]
        if len == 0 {
            return Err(bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len + bebpp::LEN_SIZE {
            return Err(bebop::DeserializeError::MoreDataExpected(len + bebop::LEN_SIZE - raw.len()));
        }
        let mut i = bebop::LEN_SIZE;
        let mut de = Self::default();

        #[cfg(not(feature = "unchecked"))]
        let mut last = 0;

        while i < len + bebop::LEN_SIZE {
            let di = raw[i];

            #[cfg(not(feature = "unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "unchecked"))]
                    if de.b.is_some() {
                        return Err(bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = <u32>::deserialize_chained(&raw[i..])?;
                    i += read;
                    de.b = Some(value)
                }
                _ => {
                    i = len + bebop::LEN_SIZE;
                    break;
                }
            }
        }
        if i != len + bebop::LEN_SIZE {
            debug_assert!(i > len + bebop::LEN_SIZE);
            Err(bebop::DeserializeError::CorruptFrame)
        }
        else {
            Ok((i, de))
        }
    }
}

impl<'raw> bebop::Record<'raw> for A {}

/// This branch is, too!
#[derive(Clone, Debug, PartialEq)]
pub struct B {
    pub c: bool,
}

impl<'raw> bebop::SubRecord<'raw> for B {
    const MIN_SERIALIZED_SIZE: usize =
        <bool>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.c.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        if raw.len() < Self::MIN_SERIALIZED_SIZE {
            let missing = raw.len() - Self::MIN_SERIALIZED_SIZE;
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let mut i = 0;
        let (read, v0) = <bool>::deserialize_chained(raw)?;
        i += read;

        Ok((i, Self {
            c: v0,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for B {}

#[derive(Clone, Debug, PartialEq)]
pub struct C {
}

impl<'raw> bebop::SubRecord<'raw> for C {
    const MIN_SERIALIZED_SIZE: usize = 0;
    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(0)
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        if raw.len() < Self::MIN_SERIALIZED_SIZE {
            let missing = raw.len() - Self::MIN_SERIALIZED_SIZE;
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let mut i = 0;

        Ok((i, Self {
        }))
    }
}

impl<'raw> bebop::Record<'raw> for C {}

/// This union is so documented!
#[derive(Clone, Debug, PartialEq)]
pub enum U {
    /// An unknown type which is likely defined in a newer version of the schema.
    Unknown,

    /// Discriminator 1
    A {
        /// Field 1
        b: core::option::Option<u32>,
    },

    /// This branch is, too!
    /// Discriminator 2
    B {
        c: bool,
    },

    /// Discriminator 3
    C {
    },
}


#[derive(Clone, Debug, PartialEq)]
pub struct TwoComesFirst {
    pub b: u8,
}

impl<'raw> bebop::SubRecord<'raw> for TwoComesFirst {
    const MIN_SERIALIZED_SIZE: usize =
        <u8>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.b.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        if raw.len() < Self::MIN_SERIALIZED_SIZE {
            let missing = raw.len() - Self::MIN_SERIALIZED_SIZE;
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let mut i = 0;
        let (read, v0) = <u8>::deserialize_chained(raw)?;
        i += read;

        Ok((i, Self {
            b: v0,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for TwoComesFirst {}

#[derive(Clone, Debug, PartialEq)]
pub struct ThreeIsSkipped {
}

impl<'raw> bebop::SubRecord<'raw> for ThreeIsSkipped {
    const MIN_SERIALIZED_SIZE: usize = 0;
    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(0)
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        if raw.len() < Self::MIN_SERIALIZED_SIZE {
            let missing = raw.len() - Self::MIN_SERIALIZED_SIZE;
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let mut i = 0;

        Ok((i, Self {
        }))
    }
}

impl<'raw> bebop::Record<'raw> for ThreeIsSkipped {}

#[derive(Clone, Debug, PartialEq)]
pub struct OneComesLast {
}

impl<'raw> bebop::SubRecord<'raw> for OneComesLast {
    const MIN_SERIALIZED_SIZE: usize = 0;
    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(0)
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        if raw.len() < Self::MIN_SERIALIZED_SIZE {
            let missing = raw.len() - Self::MIN_SERIALIZED_SIZE;
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let mut i = 0;

        Ok((i, Self {
        }))
    }
}

impl<'raw> bebop::Record<'raw> for OneComesLast {}

#[derive(Clone, Debug, PartialEq)]
pub enum WeirdOrder {
    /// An unknown type which is likely defined in a newer version of the schema.
    Unknown,

    /// Discriminator 1
    OneComesLast {
    },

    /// Discriminator 2
    TwoComesFirst {
        b: u8,
    },

    /// Discriminator 4
    ThreeIsSkipped {
    },
}


