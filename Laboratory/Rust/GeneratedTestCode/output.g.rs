//!
//! This code was generated by a tool.
//!
//!
//!   bebopc version:
//!       0.0.1-20210727-1716
//!
//!
//!   bebopc source:
//!       https://github.com/RainwayApp/bebop
//!
//!
//! Changes to this file may cause incorrect behavior and will be lost if
//! the code is regenerated.
//!

use bebop::{Record as _, SubRecord as _};

#[derive(Clone, Debug, PartialEq, Default)]
pub struct M {
    /// Field 1
    pub a: core::option::Option<f32>,
    /// Field 2
    pub b: core::option::Option<f64>,
}

impl<'raw> bebop::SubRecord<'raw> for M {
    const MIN_SERIALIZED_SIZE: usize = bebop::LEN_SIZE + 1;
    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        let mut buf = Vec::new();
        if let Some(ref v) = self.a {
            buf.push(1);
            v.serialize(&mut buf)?;
        }
        if let Some(ref v) = self.b {
            buf.push(2);
            v.serialize(&mut buf)?;
        }
        buf.push(0);
        bebop::write_len(dest, buf.len())?;
        dest.write_all(&buf)?;
        Ok(buf.len() + bebop::LEN_SIZE)
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let len = bebop::read_len(raw)?;
        #[cfg(not(feature = "unchecked"))]
        if len == 0 {
            return Err(bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len + bebpp::LEN_SIZE {
            return Err(bebop::DeserializeError::MoreDataExpected(len + bebop::LEN_SIZE - raw.len()));
        }
        let mut i = bebop::LEN_SIZE;
        let mut de = Self::default();

        #[cfg(not(feature = "unchecked"))]
        let mut last = 0;

        while i < len + bebop::LEN_SIZE {
            let di = raw[i];

            #[cfg(not(feature = "unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "unchecked"))]
                    if de.a.is_some() {
                        return Err(bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = <f32>::deserialize_chained(&raw[i..])?;
                    i += read;
                    de.a = Some(value)
                }
                2 => {
                    #[cfg(not(feature = "unchecked"))]
                    if de.b.is_some() {
                        return Err(bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = <f64>::deserialize_chained(&raw[i..])?;
                    i += read;
                    de.b = Some(value)
                }
                _ => {
                    i = len + bebop::LEN_SIZE;
                    break;
                }
            }
        }
        if i != len + bebop::LEN_SIZE {
            debug_assert!(i > len + bebop::LEN_SIZE);
            Err(bebop::DeserializeError::CorruptFrame)
        }
        else {
            Ok((i, de))
        }
    }
}

impl<'raw> bebop::Record<'raw> for M {}

/// other docs
#[derive(Clone, Debug, PartialEq, Default)]
pub struct InnerM {
    /// Field 1
    pub x: core::option::Option<i32>,
}

impl<'raw> bebop::SubRecord<'raw> for InnerM {
    const MIN_SERIALIZED_SIZE: usize = bebop::LEN_SIZE + 1;
    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        let mut buf = Vec::new();
        if let Some(ref v) = self.x {
            buf.push(1);
            v.serialize(&mut buf)?;
        }
        buf.push(0);
        bebop::write_len(dest, buf.len())?;
        dest.write_all(&buf)?;
        Ok(buf.len() + bebop::LEN_SIZE)
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let len = bebop::read_len(raw)?;
        #[cfg(not(feature = "unchecked"))]
        if len == 0 {
            return Err(bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len + bebpp::LEN_SIZE {
            return Err(bebop::DeserializeError::MoreDataExpected(len + bebop::LEN_SIZE - raw.len()));
        }
        let mut i = bebop::LEN_SIZE;
        let mut de = Self::default();

        #[cfg(not(feature = "unchecked"))]
        let mut last = 0;

        while i < len + bebop::LEN_SIZE {
            let di = raw[i];

            #[cfg(not(feature = "unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "unchecked"))]
                    if de.x.is_some() {
                        return Err(bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = <i32>::deserialize_chained(&raw[i..])?;
                    i += read;
                    de.x = Some(value)
                }
                _ => {
                    i = len + bebop::LEN_SIZE;
                    break;
                }
            }
        }
        if i != len + bebop::LEN_SIZE {
            debug_assert!(i > len + bebop::LEN_SIZE);
            Err(bebop::DeserializeError::CorruptFrame)
        }
        else {
            Ok((i, de))
        }
    }
}

impl<'raw> bebop::Record<'raw> for InnerM {}

#[derive(Clone, Debug, PartialEq)]
pub struct InnerS {
    pub y: bool,
}

impl<'raw> bebop::SubRecord<'raw> for InnerS {
    const MIN_SERIALIZED_SIZE: usize =
        <bool>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.y.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        if raw.len() < Self::MIN_SERIALIZED_SIZE {
            let missing = raw.len() - Self::MIN_SERIALIZED_SIZE;
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let mut i = 0;
        let (read, v0) = <bool>::deserialize_chained(raw)?;
        i += read;

        Ok((i, Self {
            y: v0,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for InnerS {}

#[derive(Clone, Debug, PartialEq, Default)]
pub struct OuterM {
    /// Field 1
    #[deprecated(note = "reasons")]
    pub innerm: core::option::Option<InnerM>,
    /// some docs
    /// Field 2
    pub inners: core::option::Option<InnerS>,
}

impl<'raw> bebop::SubRecord<'raw> for OuterM {
    const MIN_SERIALIZED_SIZE: usize = bebop::LEN_SIZE + 1;
    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        let mut buf = Vec::new();
        if let Some(ref v) = self.innerm {
            buf.push(1);
            v.serialize(&mut buf)?;
        }
        if let Some(ref v) = self.inners {
            buf.push(2);
            v.serialize(&mut buf)?;
        }
        buf.push(0);
        bebop::write_len(dest, buf.len())?;
        dest.write_all(&buf)?;
        Ok(buf.len() + bebop::LEN_SIZE)
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        let len = bebop::read_len(raw)?;
        #[cfg(not(feature = "unchecked"))]
        if len == 0 {
            return Err(bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len + bebpp::LEN_SIZE {
            return Err(bebop::DeserializeError::MoreDataExpected(len + bebop::LEN_SIZE - raw.len()));
        }
        let mut i = bebop::LEN_SIZE;
        let mut de = Self::default();

        #[cfg(not(feature = "unchecked"))]
        let mut last = 0;

        while i < len + bebop::LEN_SIZE {
            let di = raw[i];

            #[cfg(not(feature = "unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "unchecked"))]
                    if de.innerm.is_some() {
                        return Err(bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = <InnerM>::deserialize_chained(&raw[i..])?;
                    i += read;
                    de.innerm = Some(value)
                }
                2 => {
                    #[cfg(not(feature = "unchecked"))]
                    if de.inners.is_some() {
                        return Err(bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = <InnerS>::deserialize_chained(&raw[i..])?;
                    i += read;
                    de.inners = Some(value)
                }
                _ => {
                    i = len + bebop::LEN_SIZE;
                    break;
                }
            }
        }
        if i != len + bebop::LEN_SIZE {
            debug_assert!(i > len + bebop::LEN_SIZE);
            Err(bebop::DeserializeError::CorruptFrame)
        }
        else {
            Ok((i, de))
        }
    }
}

impl<'raw> bebop::Record<'raw> for OuterM {
    const OPCODE: core::option::Option<u32> = Some(0x36A);
}

#[derive(Clone, Debug, PartialEq)]
pub struct OuterS {
    pub innerm: InnerM,
    pub inners: InnerS,
}

impl<'raw> bebop::SubRecord<'raw> for OuterS {
    const MIN_SERIALIZED_SIZE: usize =
        <InnerM>::MIN_SERIALIZED_SIZE +
        <InnerS>::MIN_SERIALIZED_SIZE;

    fn serialize<W: std::io::Write>(&self, dest: &mut W) -> bebop::SeResult<usize> {
        Ok(
            self.innerM.serialize(dest)? +
            self.innerS.serialize(dest)?
        )
    }

    fn deserialize_chained(raw: &'raw [u8]) -> bebop::DeResult<(usize, Self)> {
        if raw.len() < Self::MIN_SERIALIZED_SIZE {
            let missing = raw.len() - Self::MIN_SERIALIZED_SIZE;
            return Err(bebop::DeserializeError::MoreDataExpected(missing));
        }

        let mut i = 0;
        let (read, v0) = <InnerM>::deserialize_chained(raw)?;
        i += read;
        let (read, v1) = <InnerS>::deserialize_chained(raw)?;
        i += read;

        Ok((i, Self {
            innerm: v0,
            inners: v1,
        }))
    }
}

impl<'raw> bebop::Record<'raw> for OuterS {}

